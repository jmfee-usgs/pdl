<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Base64.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.util</a> &gt; <span class="el_source">Base64.java</span></div><h1>Base64.java</h1><pre class="source lang-java linenums">package gov.usgs.util;

/**
 * &lt;p&gt;
 * Encodes and decodes to and from Base64 notation.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Homepage: &lt;a href=&quot;http://iharder.net/base64&quot;&gt;http://iharder.net/base64&lt;/a&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 *
 * &lt;code&gt;String encoded = Base64.encode( myByteArray );&lt;/code&gt; &lt;br &gt;
 * &lt;code&gt;byte[] myByteArray = Base64.decode( encoded );&lt;/code&gt;
 *
 * &lt;p&gt;
 * The &lt;tt&gt;options&lt;/tt&gt; parameter, which appears in a few places, is used to
 * pass several pieces of information to the encoder. In the &quot;higher level&quot;
 * methods such as encodeBytes( bytes, options ) the options parameter can be
 * used to indicate such things as first gzipping the bytes before encoding
 * them, not inserting linefeeds, and encoding using the URL-safe and Ordered
 * dialects.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Note, according to &lt;a
 * href=&quot;http://www.faqs.org/rfcs/rfc3548.html&quot;&gt;RFC3548&lt;/a&gt;, Section 2.1,
 * implementations should not add line feeds unless explicitly told to do so.
 * I've got Base64 set to this behavior now, although earlier versions broke
 * lines by default.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The constants defined in Base64 can be OR-ed together to combine options, so
 * you might make a call like this:
 * &lt;/p&gt;
 *
 * &lt;code&gt;String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );&lt;/code&gt;
 * &lt;p&gt;
 * to compress the data before encoding it and then making the output have
 * newline characters.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Also...
 * &lt;/p&gt;
 * &lt;code&gt;String encoded = Base64.encodeBytes( crazyString.getBytes() );&lt;/code&gt;
 *
 *
 *
 * &lt;p&gt;
 * Change Log:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;v2.3.4 - Fixed bug when working with gzipped streams whereby flushing the
 * Base64.OutputStream closed the Base64 encoding (by padding with equals signs)
 * too soon. Also added an option to suppress the automatic decoding of gzipped
 * streams. Also added experimental support for specifying a class loader when
 * using the
 * {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)} method.
 * &lt;/li&gt;
 * &lt;li&gt;v2.3.3 - Changed default char encoding to US-ASCII which reduces the
 * internal Java footprint with its CharEncoders and so forth. Fixed some
 * javadocs that were inconsistent. Removed imports and specified things like
 * java.io.IOException explicitly inline.&lt;/li&gt;
 * &lt;li&gt;v2.3.2 - Reduced memory footprint! Finally refined the &quot;guessing&quot; of how
 * big the final encoded data will be so that the code doesn't have to create
 * two output arrays: an oversized initial one and then a final, exact-sized
 * one. Big win when using the {@link #encodeBytesToBytes(byte[])} family of
 * methods (and not using the gzip options which uses a different mechanism with
 * streams and stuff).&lt;/li&gt;
 * &lt;li&gt;v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and
 * some similar helper methods to be more efficient with memory by not returning
 * a String but just a byte array.&lt;/li&gt;
 * &lt;li&gt;v2.3 - &lt;strong&gt;This is not a drop-in replacement!&lt;/strong&gt; This is two
 * years of comments and bug fixes queued up and finally executed. Thanks to
 * everyone who sent me stuff, and I'm sorry I wasn't able to distribute your
 * fixes to everyone else. Much bad coding was cleaned up including throwing
 * exceptions where necessary instead of returning null values or something
 * similar. Here are some changes that may affect you:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;em&gt;Does not break lines, by default.&lt;/em&gt; This is to keep in compliance
 * with &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3548.html&quot;&gt;RFC3548&lt;/a&gt;.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;Throws exceptions instead of returning null values.&lt;/em&gt; Because some
 * operations (especially those that may permit the GZIP option) use IO streams,
 * there is a possiblity of an java.io.IOException being thrown. After some
 * discussion and thought, I've changed the behavior of the methods to throw
 * java.io.IOExceptions rather than return null if ever there's an error. I
 * think this is more appropriate, though it will require some changes to your
 * code. Sorry, it should have been done this way to begin with.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;Removed all references to System.out, System.err, and the like.&lt;/em&gt;
 * Shame on me. All I can say is sorry they were ever there.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;Throws NullPointerExceptions and IllegalArgumentExceptions&lt;/em&gt; as
 * needed such as when passed arrays are null or offsets are invalid.&lt;/li&gt;
 * &lt;li&gt;Cleaned up as much javadoc as I could to avoid any javadoc warnings. This
 * was especially annoying before for people who were thorough in their own
 * projects and then had gobs of javadoc warnings on this file.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;li&gt;v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug when
 * using very small files (~ 40 bytes).&lt;/li&gt;
 * &lt;li&gt;v2.2 - Added some helper methods for encoding/decoding directly from one
 * file to the next. Also added a main() method to support command line
 * encoding/decoding from one file to the next. Also added these Base64
 * dialects:
 * &lt;ol&gt;
 * &lt;li&gt;The default is RFC3548 format.&lt;/li&gt;
 * &lt;li&gt;Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates
 * URL and file name friendly format as described in Section 4 of RFC3548.
 * http://www.faqs.org/rfcs/rfc3548.html&lt;/li&gt;
 * &lt;li&gt;Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates
 * URL and file name friendly format that preserves lexical ordering as
 * described in http://www.faqs.org/qa/rfcc-1940.html&lt;/li&gt;
 * &lt;/ol&gt;
 * Special thanks to Jim Kellerman at &lt;a
 * href=&quot;http://www.powerset.com/&quot;&gt;http://www.powerset.com/&lt;/a&gt; for contributing
 * the new Base64 dialects.&lt;/li&gt;
 *
 * &lt;li&gt;v2.1 - Cleaned up javadoc comments and unused variables and methods.
 * Added some convenience methods for reading and writing to and from files.&lt;/li&gt;
 * &lt;li&gt;v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on
 * systems with other encodings (like EBCDIC).&lt;/li&gt;
 * &lt;li&gt;v2.0.1 - Fixed an error when decoding a single byte, that is, when the
 * encoded data was a single byte.&lt;/li&gt;
 * &lt;li&gt;v2.0 - I got rid of methods that used booleans to set options. Now
 * everything is more consolidated and cleaner. The code now detects when data
 * that's being decoded is gzip-compressed and will decompress it automatically.
 * Generally things are cleaner. You'll probably have to change some method
 * calls that you were making to support the new options format (&lt;tt&gt;int&lt;/tt&gt;s
 * that you &quot;OR&quot; together).&lt;/li&gt;
 * &lt;li&gt;v1.5.1 - Fixed bug when decompressing and decoding to a byte[] using
 * &lt;tt&gt;decode( String s, boolean gzipCompressed )&lt;/tt&gt;. Added the ability to
 * &quot;suspend&quot; encoding in the Output Stream so you can turn on and off the
 * encoding if you need to embed base64 data in an otherwise &quot;normal&quot; stream
 * (like an XML file).&lt;/li&gt;
 * &lt;li&gt;v1.5 - Output stream pases on flush() command but doesn't do anything
 * itself. This helps when using GZIP streams. Added the ability to
 * GZip-compress objects before encoding them.&lt;/li&gt;
 * &lt;li&gt;v1.4 - Added helper methods to read/write files.&lt;/li&gt;
 * &lt;li&gt;v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.&lt;/li&gt;
 * &lt;li&gt;v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input
 * stream where last buffer being read, if not completely full, was not
 * returned.&lt;/li&gt;
 * &lt;li&gt;v1.3.4 - Fixed when &quot;improperly padded stream&quot; error was thrown at the
 * wrong time.&lt;/li&gt;
 * &lt;li&gt;v1.3.3 - Fixed I/O streams which were totally messed up.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * I am placing this code in the Public Domain. Do with it as you will. This
 * software comes with no guarantees or warranties but with plenty of
 * well-wishing instead! Please visit &lt;a
 * href=&quot;http://iharder.net/base64&quot;&gt;http://iharder.net/base64&lt;/a&gt; periodically
 * to check for updates or to contribute improvements.
 * &lt;/p&gt;
 *
 * @author Robert Harder
 * @author rob@iharder.net
 * @version 2.3.3
 */
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">public class Base64 {</span>

    /* P U B L I C F I E L D S */

    /** No options specified. Value is zero. */
    public final static int NO_OPTIONS = 0;

    /** Specify encoding in first bit. Value is one. */
    public final static int ENCODE = 1;

    /** Specify decoding in first bit. Value is zero. */
    public final static int DECODE = 0;

    /** Specify that data should be gzip-compressed in second bit. Value is two. */
    public final static int GZIP = 2;

    /**
     * Specify that gzipped data should &lt;em&gt;not&lt;/em&gt; be automatically gunzipped.
     */
    public final static int DONT_GUNZIP = 4;

    /** Do break lines when encoding. Value is 8. */
    public final static int DO_BREAK_LINES = 8;

    /**
     * Encode using Base64-like encoding that is URL- and Filename-safe as
     * described in Section 4 of RFC3548: &lt;a
     * href=&quot;http://www.faqs.org/rfcs/rfc3548.html&quot;
     * &gt;http://www.faqs.org/rfcs/rfc3548.html&lt;/a&gt;. It is important to note that
     * data encoded this way is &lt;em&gt;not&lt;/em&gt; officially valid Base64, or at the
     * very least should not be called Base64 without also specifying that is
     * was encoded using the URL- and Filename-safe dialect.
     */
    public final static int URL_SAFE = 16;

    /**
     * Encode using the special &quot;ordered&quot; dialect of Base64 described here: &lt;a
     * href=&quot;http://www.faqs.org/qa/rfcc-1940.html&quot;&gt;http://www.faqs.org/qa/rfcc-
     * 1940.html&lt;/a&gt;.
     */
    public final static int ORDERED = 32;

    /* P R I V A T E F I E L D S */

    /** Maximum line length (76) of Base64 output. */
    private final static int MAX_LINE_LENGTH = 76;

    /** The equals sign (=) as a byte. */
    private final static byte EQUALS_SIGN = (byte) '=';

    /** The new line character (\n) as a byte. */
    private final static byte NEW_LINE = (byte) '\n';

    /** Preferred encoding. */
    private final static String PREFERRED_ENCODING = &quot;US-ASCII&quot;;

    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in
    // encoding
    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in
    // encoding

    /* S T A N D A R D B A S E 6 4 A L P H A B E T */

    /** The 64 valid Base64 values. */
    /*
     * Host platform me be something funny like EBCDIC, so we hardcode these
     * values.
     */
<span class="fc" id="L229">    private final static byte[] _STANDARD_ALPHABET = { (byte) 'A', (byte) 'B',</span>
            (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G',
            (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L',
            (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q',
            (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V',
            (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a',
            (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f',
            (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k',
            (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p',
            (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u',
            (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z',
            (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4',
            (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9',
            (byte) '+', (byte) '/' };

    /**
     * Translates a Base64 value to either its 6-bit reconstruction value or a
     * negative number indicating some other meaning.
     **/
<span class="fc" id="L248">    private final static byte[] _STANDARD_DECODABET = { -9, -9, -9, -9, -9, -9,</span>
            -9, -9, -9, // Decimal 0 - 8
            -5, -5, // Whitespace: Tab and Linefeed
            -9, -9, // Decimal 11 - 12
            -5, // Whitespace: Carriage Return
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
            // 26
            -9, -9, -9, -9, -9, // Decimal 27 - 31
            -5, // Whitespace: Space
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
            62, // Plus sign at decimal 43
            -9, -9, -9, // Decimal 44 - 46
            63, // Slash at decimal 47
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
            -9, -9, -9, // Decimal 58 - 60
            -1, // Equals sign at decimal 61
            -9, -9, -9, // Decimal 62 - 64
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through
            // 'N'
            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O'
            // through 'Z'
            -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a'
            // through 'm'
            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n'
            // through 'z'
            -9, -9, -9, -9 // Decimal 123 - 126
    /*
     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 140 - 152
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 166 - 178
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 205 - 217
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 231 - 243
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
     */
    };

    /* U R L S A F E B A S E 6 4 A L P H A B E T */

    /**
     * Used in the URL- and Filename-safe dialect described in Section 4 of
     * RFC3548: &lt;a
     * href=&quot;http://www.faqs.org/rfcs/rfc3548.html&quot;&gt;http://www.faqs.org
     * /rfcs/rfc3548.html&lt;/a&gt;. Notice that the last two bytes become &quot;hyphen&quot;
     * and &quot;underscore&quot; instead of &quot;plus&quot; and &quot;slash.&quot;
     */
<span class="fc" id="L298">    private final static byte[] _URL_SAFE_ALPHABET = { (byte) 'A', (byte) 'B',</span>
            (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G',
            (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L',
            (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q',
            (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V',
            (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a',
            (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f',
            (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k',
            (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p',
            (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u',
            (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z',
            (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4',
            (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9',
            (byte) '-', (byte) '_' };

    /**
     * Used in decoding URL- and Filename-safe dialects of Base64.
     */
<span class="fc" id="L316">    private final static byte[] _URL_SAFE_DECODABET = { -9, -9, -9, -9, -9, -9,</span>
            -9, -9, -9, // Decimal 0 - 8
            -5, -5, // Whitespace: Tab and Linefeed
            -9, -9, // Decimal 11 - 12
            -5, // Whitespace: Carriage Return
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
            // 26
            -9, -9, -9, -9, -9, // Decimal 27 - 31
            -5, // Whitespace: Space
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
            -9, // Plus sign at decimal 43
            -9, // Decimal 44
            62, // Minus sign at decimal 45
            -9, // Decimal 46
            -9, // Slash at decimal 47
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
            -9, -9, -9, // Decimal 58 - 60
            -1, // Equals sign at decimal 61
            -9, -9, -9, // Decimal 62 - 64
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through
            // 'N'
            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O'
            // through 'Z'
            -9, -9, -9, -9, // Decimal 91 - 94
            63, // Underscore at decimal 95
            -9, // Decimal 96
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a'
            // through 'm'
            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n'
            // through 'z'
            -9, -9, -9, -9 // Decimal 123 - 126
    /*
     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 140 - 152
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 166 - 178
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 205 - 217
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 231 - 243
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
     */
    };

    /* O R D E R E D B A S E 6 4 A L P H A B E T */

    /**
     * I don't get the point of this technique, but someone requested it, and it
     * is described here: &lt;a
     * href=&quot;http://www.faqs.org/qa/rfcc-1940.html&quot;&gt;http://
     * www.faqs.org/qa/rfcc-1940.html&lt;/a&gt;.
     */
<span class="fc" id="L369">    private final static byte[] _ORDERED_ALPHABET = { (byte) '-', (byte) '0',</span>
            (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5',
            (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'A',
            (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
            (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
            (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
            (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
            (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
            (byte) '_', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd',
            (byte) 'e', (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i',
            (byte) 'j', (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n',
            (byte) 'o', (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's',
            (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x',
            (byte) 'y', (byte) 'z' };

    /**
     * Used in decoding the &quot;ordered&quot; dialect of Base64.
     */
<span class="fc" id="L387">    private final static byte[] _ORDERED_DECODABET = { -9, -9, -9, -9, -9, -9,</span>
            -9, -9, -9, // Decimal 0 - 8
            -5, -5, // Whitespace: Tab and Linefeed
            -9, -9, // Decimal 11 - 12
            -5, // Whitespace: Carriage Return
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
            // 26
            -9, -9, -9, -9, -9, // Decimal 27 - 31
            -5, // Whitespace: Space
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
            -9, // Plus sign at decimal 43
            -9, // Decimal 44
            0, // Minus sign at decimal 45
            -9, // Decimal 46
            -9, // Slash at decimal 47
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, // Numbers zero through nine
            -9, -9, -9, // Decimal 58 - 60
            -1, // Equals sign at decimal 61
            -9, -9, -9, // Decimal 62 - 64
            11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, // Letters 'A'
            // through 'M'
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, // Letters 'N'
            // through 'Z'
            -9, -9, -9, -9, // Decimal 91 - 94
            37, // Underscore at decimal 95
            -9, // Decimal 96
            38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, // Letters 'a'
            // through 'm'
            51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, // Letters 'n'
            // through 'z'
            -9, -9, -9, -9 // Decimal 123 - 126
    /*
     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 140 - 152
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 166 - 178
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 205 - 217
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 231 - 243
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
     */
    };

    /* D E T E R M I N E W H I C H A L H A B E T */

    /**
     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on the
     * options specified. It's possible, though silly, to specify ORDERED
     * &lt;b&gt;and&lt;/b&gt; URLSAFE in which case one of them will be picked, though there
     * is no guarantee as to which one will be picked.
     */
    private final static byte[] getAlphabet(int options) {
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if ((options &amp; URL_SAFE) == URL_SAFE) {</span>
<span class="nc" id="L442">            return _URL_SAFE_ALPHABET;</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        } else if ((options &amp; ORDERED) == ORDERED) {</span>
<span class="nc" id="L444">            return _ORDERED_ALPHABET;</span>
        } else {
<span class="fc" id="L446">            return _STANDARD_ALPHABET;</span>
        }
    } // end getAlphabet

    /**
     * Returns one of the _SOMETHING_DECODABET byte arrays depending on the
     * options specified. It's possible, though silly, to specify ORDERED and
     * URL_SAFE in which case one of them will be picked, though there is no
     * guarantee as to which one will be picked.
     */
    private final static byte[] getDecodabet(int options) {
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">        if ((options &amp; URL_SAFE) == URL_SAFE) {</span>
<span class="nc" id="L458">            return _URL_SAFE_DECODABET;</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        } else if ((options &amp; ORDERED) == ORDERED) {</span>
<span class="nc" id="L460">            return _ORDERED_DECODABET;</span>
        } else {
<span class="fc" id="L462">            return _STANDARD_DECODABET;</span>
        }
    } // end getAlphabet

    /** Defeats instantiation. */
    private Base64() {
    }

    /* E N C O D I N G M E T H O D S */

    /**
     * Encodes up to the first three bytes of array &lt;var&gt;threeBytes&lt;/var&gt; and
     * returns a four-byte array in Base64 notation. The actual number of
     * significant bytes in your array is given by &lt;var&gt;numSigBytes&lt;/var&gt;. The
     * array &lt;var&gt;threeBytes&lt;/var&gt; needs only be as big as
     * &lt;var&gt;numSigBytes&lt;/var&gt;. Code can reuse a byte array by passing a
     * four-byte array as &lt;var&gt;b4&lt;/var&gt;.
     *
     * @param b4
     *            A reusable byte array to reduce array instantiation
     * @param threeBytes
     *            the array to convert
     * @param numSigBytes
     *            the number of significant bytes in your array
     * @return four byte array in Base64 notation.
     * @since 1.5.1
     */
    private static byte[] encode3to4(byte[] b4, byte[] threeBytes,
            int numSigBytes, int options) {
<span class="fc" id="L491">        encode3to4(threeBytes, 0, numSigBytes, b4, 0, options);</span>
<span class="fc" id="L492">        return b4;</span>
    } // end encode3to4

    /**
     * &lt;p&gt;
     * Encodes up to three bytes of the array &lt;var&gt;source&lt;/var&gt; and writes the
     * resulting four Base64 bytes to &lt;var&gt;destination&lt;/var&gt;. The source and
     * destination arrays can be manipulated anywhere along their length by
     * specifying &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;. This method
     * does not check to make sure your arrays are large enough to accomodate
     * &lt;var&gt;srcOffset&lt;/var&gt; + 3 for the &lt;var&gt;source&lt;/var&gt; array or
     * &lt;var&gt;destOffset&lt;/var&gt; + 4 for the &lt;var&gt;destination&lt;/var&gt; array. The
     * actual number of significant bytes in your array is given by
     * &lt;var&gt;numSigBytes&lt;/var&gt;.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This is the lowest level of the encoding methods with all possible
     * parameters.
     * &lt;/p&gt;
     *
     * @param source
     *            the array to convert
     * @param srcOffset
     *            the index where conversion begins
     * @param numSigBytes
     *            the number of significant bytes in your array
     * @param destination
     *            the array to hold the conversion
     * @param destOffset
     *            the index where output will be put
     * @return the &lt;var&gt;destination&lt;/var&gt; array
     * @since 1.3
     */
    private static byte[] encode3to4(byte[] source, int srcOffset,
            int numSigBytes, byte[] destination, int destOffset, int options) {

<span class="fc" id="L528">        byte[] ALPHABET = getAlphabet(options);</span>

        // 1 2 3
        // 01234567890123456789012345678901 Bit position
        // --------000000001111111122222222 Array position from threeBytes
        // --------| || || || | Six bit groups to index ALPHABET
        // &gt;&gt;18 &gt;&gt;12 &gt;&gt; 6 &gt;&gt; 0 Right shift necessary
        // 0x3f 0x3f 0x3f Additional AND

        // Create buffer with zero-padding if there are only one or two
        // significant bytes passed in the array.
        // We have to shift left 24 in order to flush out the 1's that appear
        // when Java treats a value as negative that is cast from a byte to an
        // int.
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        int inBuff = (numSigBytes &gt; 0 ? ((source[srcOffset] &lt;&lt; 24) &gt;&gt;&gt; 8) : 0)</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">                | (numSigBytes &gt; 1 ? ((source[srcOffset + 1] &lt;&lt; 24) &gt;&gt;&gt; 16) : 0)</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">                | (numSigBytes &gt; 2 ? ((source[srcOffset + 2] &lt;&lt; 24) &gt;&gt;&gt; 24) : 0);</span>

<span class="pc bpc" id="L546" title="1 of 4 branches missed.">        switch (numSigBytes) {</span>
        case 3:
<span class="fc" id="L548">            destination[destOffset] = ALPHABET[(inBuff &gt;&gt;&gt; 18)];</span>
<span class="fc" id="L549">            destination[destOffset + 1] = ALPHABET[(inBuff &gt;&gt;&gt; 12) &amp; 0x3f];</span>
<span class="fc" id="L550">            destination[destOffset + 2] = ALPHABET[(inBuff &gt;&gt;&gt; 6) &amp; 0x3f];</span>
<span class="fc" id="L551">            destination[destOffset + 3] = ALPHABET[(inBuff) &amp; 0x3f];</span>
<span class="fc" id="L552">            return destination;</span>

        case 2:
<span class="fc" id="L555">            destination[destOffset] = ALPHABET[(inBuff &gt;&gt;&gt; 18)];</span>
<span class="fc" id="L556">            destination[destOffset + 1] = ALPHABET[(inBuff &gt;&gt;&gt; 12) &amp; 0x3f];</span>
<span class="fc" id="L557">            destination[destOffset + 2] = ALPHABET[(inBuff &gt;&gt;&gt; 6) &amp; 0x3f];</span>
<span class="fc" id="L558">            destination[destOffset + 3] = EQUALS_SIGN;</span>
<span class="fc" id="L559">            return destination;</span>

        case 1:
<span class="fc" id="L562">            destination[destOffset] = ALPHABET[(inBuff &gt;&gt;&gt; 18)];</span>
<span class="fc" id="L563">            destination[destOffset + 1] = ALPHABET[(inBuff &gt;&gt;&gt; 12) &amp; 0x3f];</span>
<span class="fc" id="L564">            destination[destOffset + 2] = EQUALS_SIGN;</span>
<span class="fc" id="L565">            destination[destOffset + 3] = EQUALS_SIGN;</span>
<span class="fc" id="L566">            return destination;</span>

        default:
<span class="nc" id="L569">            return destination;</span>
        } // end switch
    } // end encode3to4

    /**
     * Performs Base64 encoding on the &lt;code&gt;raw&lt;/code&gt; ByteBuffer, writing it
     * to the &lt;code&gt;encoded&lt;/code&gt; ByteBuffer. This is an experimental feature.
     * Currently it does not pass along any options (such as
     * {@link #DO_BREAK_LINES} or {@link #GZIP}.
     *
     * @param raw
     *            input buffer
     * @param encoded
     *            output buffer
     * @since 2.3
     */
    public static void encode(java.nio.ByteBuffer raw,
            java.nio.ByteBuffer encoded) {
<span class="nc" id="L587">        byte[] raw3 = new byte[3];</span>
<span class="nc" id="L588">        byte[] enc4 = new byte[4];</span>

<span class="nc bnc" id="L590" title="All 2 branches missed.">        while (raw.hasRemaining()) {</span>
<span class="nc" id="L591">            int rem = Math.min(3, raw.remaining());</span>
<span class="nc" id="L592">            raw.get(raw3, 0, rem);</span>
<span class="nc" id="L593">            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS);</span>
<span class="nc" id="L594">            encoded.put(enc4);</span>
<span class="nc" id="L595">        } // end input remaining</span>
<span class="nc" id="L596">    }</span>

    /**
     * Performs Base64 encoding on the &lt;code&gt;raw&lt;/code&gt; ByteBuffer, writing it
     * to the &lt;code&gt;encoded&lt;/code&gt; CharBuffer. This is an experimental feature.
     * Currently it does not pass along any options (such as
     * {@link #DO_BREAK_LINES} or {@link #GZIP}.
     *
     * @param raw
     *            input buffer
     * @param encoded
     *            output buffer
     * @since 2.3
     */
    public static void encode(java.nio.ByteBuffer raw,
            java.nio.CharBuffer encoded) {
<span class="nc" id="L612">        byte[] raw3 = new byte[3];</span>
<span class="nc" id="L613">        byte[] enc4 = new byte[4];</span>

<span class="nc bnc" id="L615" title="All 2 branches missed.">        while (raw.hasRemaining()) {</span>
<span class="nc" id="L616">            int rem = Math.min(3, raw.remaining());</span>
<span class="nc" id="L617">            raw.get(raw3, 0, rem);</span>
<span class="nc" id="L618">            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS);</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            for (int i = 0; i &lt; 4; i++) {</span>
<span class="nc" id="L620">                encoded.put((char) (enc4[i] &amp; 0xFF));</span>
            }
<span class="nc" id="L622">        } // end input remaining</span>
<span class="nc" id="L623">    }</span>

    /**
     * Serializes an object and returns the Base64-encoded version of that
     * serialized object.
     *
     * &lt;p&gt;
     * As of v 2.3, if the object cannot be serialized or there is another
     * error, the method will throw an java.io.IOException. &lt;b&gt;This is new to
     * v2.3!&lt;/b&gt; In earlier versions, it just returned a null value, but in
     * retrospect that's a pretty poor way to handle it.
     * &lt;/p&gt;
     *
     * The object is not GZip-compressed before being encoded.
     *
     * @param serializableObject
     *            The object to encode
     * @return The Base64-encoded object
     * @throws java.io.IOException
     *             if there is an error
     * @throws NullPointerException
     *             if serializedObject is null
     * @since 1.4
     */
    public static String encodeObject(java.io.Serializable serializableObject)
            throws java.io.IOException {
<span class="nc" id="L649">        return encodeObject(serializableObject, NO_OPTIONS);</span>
    } // end encodeObject

    /**
     * Serializes an object and returns the Base64-encoded version of that
     * serialized object.
     *
     * &lt;p&gt;
     * As of v 2.3, if the object cannot be serialized or there is another
     * error, the method will throw an java.io.IOException. &lt;b&gt;This is new to
     * v2.3!&lt;/b&gt; In earlier versions, it just returned a null value, but in
     * retrospect that's a pretty poor way to handle it.
     * &lt;/p&gt;
     *
     * The object is not GZip-compressed before being encoded.
     * &lt;p&gt;
     * Example options:
     *
     * &lt;pre&gt;
     *   GZIP: gzip-compresses object before encoding it.
     *   DO_BREAK_LINES: break lines at 76 characters
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeObject( myObj, Base64.GZIP )&lt;/code&gt; or
     * &lt;p&gt;
     * Example:
     * &lt;code&gt;encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )&lt;/code&gt;
     *
     * @param serializableObject
     *            The object to encode
     * @param options
     *            Specified options
     * @return The Base64-encoded object
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException
     *             if there is an error
     * @since 2.0
     */
    public static String encodeObject(java.io.Serializable serializableObject,
            int options) throws java.io.IOException {

<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (serializableObject == null) {</span>
<span class="nc" id="L692">            throw new NullPointerException(&quot;Cannot serialize a null object.&quot;);</span>
        } // end if: null

        // Streams
<span class="nc" id="L696">        java.io.ByteArrayOutputStream baos = null;</span>
<span class="nc" id="L697">        java.io.OutputStream b64os = null;</span>
<span class="nc" id="L698">        java.util.zip.GZIPOutputStream gzos = null;</span>
<span class="nc" id="L699">        java.io.ObjectOutputStream oos = null;</span>

        try {
            // ObjectOutputStream -&gt; (GZIP) -&gt; Base64 -&gt; ByteArrayOutputStream
<span class="nc" id="L703">            baos = new java.io.ByteArrayOutputStream();</span>
<span class="nc" id="L704">            b64os = new Base64.OutputStream(baos, ENCODE | options);</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            if ((options &amp; GZIP) != 0) {</span>
                // Gzip
<span class="nc" id="L707">                gzos = new java.util.zip.GZIPOutputStream(b64os);</span>
<span class="nc" id="L708">                oos = new java.io.ObjectOutputStream(gzos);</span>
            } else {
                // Not gzipped
<span class="nc" id="L711">                oos = new java.io.ObjectOutputStream(b64os);</span>
            }
<span class="nc" id="L713">            oos.writeObject(serializableObject);</span>
        } // end try
<span class="nc" id="L715">        catch (java.io.IOException e) {</span>
            // Catch it and then throw it immediately so that
            // the finally{} block is called for cleanup.
<span class="nc" id="L718">            throw e;</span>
        } // end catch
        finally {
            try {
<span class="nc" id="L722">                oos.close();</span>
<span class="nc" id="L723">            } catch (Exception e) {</span>
<span class="nc" id="L724">            }</span>
            try {
<span class="nc" id="L726">                gzos.close();</span>
<span class="nc" id="L727">            } catch (Exception e) {</span>
<span class="nc" id="L728">            }</span>
            try {
<span class="nc" id="L730">                b64os.close();</span>
<span class="nc" id="L731">            } catch (Exception e) {</span>
<span class="nc" id="L732">            }</span>
            try {
<span class="nc" id="L734">                baos.close();</span>
<span class="nc" id="L735">            } catch (Exception e) {</span>
<span class="nc" id="L736">            }</span>
        } // end finally

        // Return value according to relevant encoding.
        try {
<span class="nc" id="L741">            return new String(baos.toByteArray(), PREFERRED_ENCODING);</span>
        } // end try
<span class="nc" id="L743">        catch (java.io.UnsupportedEncodingException uue) {</span>
            // Fall back to some Java default
<span class="nc" id="L745">            return new String(baos.toByteArray());</span>
        } // end catch

    } // end encode

    /**
     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
     *
     * @param source
     *            The data to convert
     * @return The data in Base64-encoded form
     * @throws NullPointerException
     *             if source array is null
     * @since 1.4
     */
    public static String encodeBytes(byte[] source) {
        // Since we're not going to have the GZIP encoding turned on,
        // we're not going to have an java.io.IOException thrown, so
        // we should not force the user to have to catch it.
<span class="fc" id="L764">        String encoded = null;</span>
        try {
<span class="fc" id="L766">            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);</span>
<span class="nc" id="L767">        } catch (java.io.IOException ex) {</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">            assert false : ex.getMessage();</span>
<span class="fc" id="L769">        } // end catch</span>
<span class="pc bpc" id="L770" title="2 of 4 branches missed.">        assert encoded != null;</span>
<span class="fc" id="L771">        return encoded;</span>
    } // end encodeBytes

    /**
     * Encodes a byte array into Base64 notation.
     * &lt;p&gt;
     * Example options:
     *
     * &lt;pre&gt;
     *   GZIP: gzip-compresses object before encoding it.
     *   DO_BREAK_LINES: break lines at 76 characters
     *     &amp;lt;i&amp;gt;Note: Technically, this makes your encoding non-compliant.&amp;lt;/i&amp;gt;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
     * &lt;p&gt;
     * Example:
     * &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )&lt;/code&gt;
     *
     *
     * &lt;p&gt;
     * As of v 2.3, if there is an error with the GZIP stream, the method will
     * throw an java.io.IOException. &lt;b&gt;This is new to v2.3!&lt;/b&gt; In earlier
     * versions, it just returned a null value, but in retrospect that's a
     * pretty poor way to handle it.
     * &lt;/p&gt;
     *
     *
     * @param source
     *            The data to convert
     * @param options
     *            Specified options
     * @return The Base64-encoded data as a String
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException
     *             if there is an error
     * @throws NullPointerException
     *             if source array is null
     * @since 2.0
     */
    public static String encodeBytes(byte[] source, int options)
            throws java.io.IOException {
<span class="nc" id="L814">        return encodeBytes(source, 0, source.length, options);</span>
    } // end encodeBytes

    /**
     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
     *
     * &lt;p&gt;
     * As of v 2.3, if there is an error, the method will throw an
     * java.io.IOException. &lt;b&gt;This is new to v2.3!&lt;/b&gt; In earlier versions, it
     * just returned a null value, but in retrospect that's a pretty poor way to
     * handle it.
     * &lt;/p&gt;
     *
     *
     * @param source
     *            The data to convert
     * @param off
     *            Offset in array where conversion should begin
     * @param len
     *            Length of data to convert
     * @return The Base64-encoded data as a String
     * @throws NullPointerException
     *             if source array is null
     * @throws IllegalArgumentException
     *             if source array, offset, or length are invalid
     * @since 1.4
     */
    public static String encodeBytes(byte[] source, int off, int len) {
        // Since we're not going to have the GZIP encoding turned on,
        // we're not going to have an java.io.IOException thrown, so
        // we should not force the user to have to catch it.
<span class="nc" id="L845">        String encoded = null;</span>
        try {
<span class="nc" id="L847">            encoded = encodeBytes(source, off, len, NO_OPTIONS);</span>
<span class="nc" id="L848">        } catch (java.io.IOException ex) {</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">            assert false : ex.getMessage();</span>
<span class="nc" id="L850">        } // end catch</span>
<span class="nc bnc" id="L851" title="All 4 branches missed.">        assert encoded != null;</span>
<span class="nc" id="L852">        return encoded;</span>
    } // end encodeBytes

    /**
     * Encodes a byte array into Base64 notation.
     * &lt;p&gt;
     * Example options:
     *
     * &lt;pre&gt;
     *   GZIP: gzip-compresses object before encoding it.
     *   DO_BREAK_LINES: break lines at 76 characters
     *     &amp;lt;i&amp;gt;Note: Technically, this makes your encoding non-compliant.&amp;lt;/i&amp;gt;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
     * &lt;p&gt;
     * Example:
     * &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )&lt;/code&gt;
     *
     *
     * &lt;p&gt;
     * As of v 2.3, if there is an error with the GZIP stream, the method will
     * throw an java.io.IOException. &lt;b&gt;This is new to v2.3!&lt;/b&gt; In earlier
     * versions, it just returned a null value, but in retrospect that's a
     * pretty poor way to handle it.
     * &lt;/p&gt;
     *
     *
     * @param source
     *            The data to convert
     * @param off
     *            Offset in array where conversion should begin
     * @param len
     *            Length of data to convert
     * @param options
     *            Specified options
     * @return The Base64-encoded data as a String
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException
     *             if there is an error
     * @throws NullPointerException
     *             if source array is null
     * @throws IllegalArgumentException
     *             if source array, offset, or length are invalid
     * @since 2.0
     */
    public static String encodeBytes(byte[] source, int off, int len,
            int options) throws java.io.IOException {
<span class="fc" id="L901">        byte[] encoded = encodeBytesToBytes(source, off, len, options);</span>

        // Return value according to relevant encoding.
        try {
<span class="fc" id="L905">            return new String(encoded, PREFERRED_ENCODING);</span>
        } // end try
<span class="nc" id="L907">        catch (java.io.UnsupportedEncodingException uue) {</span>
<span class="nc" id="L908">            return new String(encoded);</span>
        } // end catch

    } // end encodeBytes

    /**
     * Similar to {@link #encodeBytes(byte[])} but returns a byte array instead
     * of instantiating a String. This is more efficient if you're working with
     * I/O streams and have large data sets to encode.
     *
     *
     * @param source
     *            The data to convert
     * @return The Base64-encoded data as a byte[] (of ASCII characters)
     * @throws NullPointerException
     *             if source array is null
     * @since 2.3.1
     */
    public static byte[] encodeBytesToBytes(byte[] source) {
<span class="nc" id="L927">        byte[] encoded = null;</span>
        try {
<span class="nc" id="L929">            encoded = encodeBytesToBytes(source, 0, source.length,</span>
                    Base64.NO_OPTIONS);
<span class="nc" id="L931">        } catch (java.io.IOException ex) {</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            assert false : &quot;IOExceptions only come from GZipping, which is turned off: &quot;</span>
<span class="nc" id="L933">                    + ex.getMessage();</span>
<span class="nc" id="L934">        }</span>
<span class="nc" id="L935">        return encoded;</span>
    }

    /**
     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns a byte
     * array instead of instantiating a String. This is more efficient if you're
     * working with I/O streams and have large data sets to encode.
     *
     *
     * @param source
     *            The data to convert
     * @param off
     *            Offset in array where conversion should begin
     * @param len
     *            Length of data to convert
     * @param options
     *            Specified options
     * @return The Base64-encoded data as a String
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException
     *             if there is an error
     * @throws NullPointerException
     *             if source array is null
     * @throws IllegalArgumentException
     *             if source array, offset, or length are invalid
     * @since 2.3.1
     */
    public static byte[] encodeBytesToBytes(byte[] source, int off, int len,
            int options) throws java.io.IOException {

<span class="pc bpc" id="L966" title="1 of 2 branches missed.">        if (source == null) {</span>
<span class="nc" id="L967">            throw new NullPointerException(&quot;Cannot serialize a null array.&quot;);</span>
        } // end if: null

<span class="pc bpc" id="L970" title="1 of 2 branches missed.">        if (off &lt; 0) {</span>
<span class="nc" id="L971">            throw new IllegalArgumentException(&quot;Cannot have negative offset: &quot;</span>
                    + off);
        } // end if: off &lt; 0

<span class="pc bpc" id="L975" title="1 of 2 branches missed.">        if (len &lt; 0) {</span>
<span class="nc" id="L976">            throw new IllegalArgumentException(&quot;Cannot have length offset: &quot;</span>
                    + len);
        } // end if: len &lt; 0

<span class="pc bpc" id="L980" title="1 of 2 branches missed.">        if (off + len &gt; source.length) {</span>
<span class="nc" id="L981">            throw new IllegalArgumentException(</span>
                    String
<span class="nc" id="L983">                            .format(</span>
                                    &quot;Cannot have offset of %d and length of %d with array of length %d&quot;,
<span class="nc" id="L985">                                    off, len, source.length));</span>
        } // end if: off &lt; 0

        // Compress?
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">        if ((options &amp; GZIP) != 0) {</span>
<span class="nc" id="L990">            java.io.ByteArrayOutputStream baos = null;</span>
<span class="nc" id="L991">            java.util.zip.GZIPOutputStream gzos = null;</span>
<span class="nc" id="L992">            Base64.OutputStream b64os = null;</span>

            try {
                // GZip -&gt; Base64 -&gt; ByteArray
<span class="nc" id="L996">                baos = new java.io.ByteArrayOutputStream();</span>
<span class="nc" id="L997">                b64os = new Base64.OutputStream(baos, ENCODE | options);</span>
<span class="nc" id="L998">                gzos = new java.util.zip.GZIPOutputStream(b64os);</span>

<span class="nc" id="L1000">                gzos.write(source, off, len);</span>
<span class="nc" id="L1001">                gzos.close();</span>
            } // end try
<span class="nc" id="L1003">            catch (java.io.IOException e) {</span>
                // Catch it and then throw it immediately so that
                // the finally{} block is called for cleanup.
<span class="nc" id="L1006">                throw e;</span>
            } // end catch
            finally {
                try {
<span class="nc" id="L1010">                    gzos.close();</span>
<span class="nc" id="L1011">                } catch (Exception e) {</span>
<span class="nc" id="L1012">                }</span>
                try {
<span class="nc" id="L1014">                    b64os.close();</span>
<span class="nc" id="L1015">                } catch (Exception e) {</span>
<span class="nc" id="L1016">                }</span>
                try {
<span class="nc" id="L1018">                    baos.close();</span>
<span class="nc" id="L1019">                } catch (Exception e) {</span>
<span class="nc" id="L1020">                }</span>
            } // end finally

<span class="nc" id="L1023">            return baos.toByteArray();</span>
        } // end if: compress

        // Else, don't compress. Better not to use streams at all then.
        else {
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">            boolean breakLines = (options &amp; DO_BREAK_LINES) &gt; 0;</span>

            // int len43 = len * 4 / 3;
            // byte[] outBuff = new byte[ ( len43 ) // Main 4:3
            // + ( (len % 3) &gt; 0 ? 4 : 0 ) // Account for padding
            // + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines
            // Try to determine more precisely how big the array needs to be.
            // If we get it right, we don't have to do an array copy, and
            // we save a bunch of memory.
<span class="fc bfc" id="L1037" title="All 2 branches covered.">            int encLen = (len / 3) * 4 + (len % 3 &gt; 0 ? 4 : 0); // Bytes needed</span>
            // for actual
            // encoding
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">            if (breakLines) {</span>
<span class="nc" id="L1041">                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline</span>
                // characters
            }
<span class="fc" id="L1044">            byte[] outBuff = new byte[encLen];</span>

<span class="fc" id="L1046">            int d = 0;</span>
<span class="fc" id="L1047">            int e = 0;</span>
<span class="fc" id="L1048">            int len2 = len - 2;</span>
<span class="fc" id="L1049">            int lineLength = 0;</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">            for (; d &lt; len2; d += 3, e += 4) {</span>
<span class="fc" id="L1051">                encode3to4(source, d + off, 3, outBuff, e, options);</span>

<span class="fc" id="L1053">                lineLength += 4;</span>
<span class="pc bpc" id="L1054" title="3 of 4 branches missed.">                if (breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH) {</span>
<span class="nc" id="L1055">                    outBuff[e + 4] = NEW_LINE;</span>
<span class="nc" id="L1056">                    e++;</span>
<span class="nc" id="L1057">                    lineLength = 0;</span>
                } // end if: end of line
            } // en dfor: each piece of array

<span class="fc bfc" id="L1061" title="All 2 branches covered.">            if (d &lt; len) {</span>
<span class="fc" id="L1062">                encode3to4(source, d + off, len - d, outBuff, e, options);</span>
<span class="fc" id="L1063">                e += 4;</span>
            } // end if: some padding needed

            // Only resize array if we didn't guess it right.
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">            if (e &lt; outBuff.length - 1) {</span>
<span class="nc" id="L1068">                byte[] finalOut = new byte[e];</span>
<span class="nc" id="L1069">                System.arraycopy(outBuff, 0, finalOut, 0, e);</span>
                // System.err.println(&quot;Having to resize array from &quot; +
                // outBuff.length + &quot; to &quot; + e );
<span class="nc" id="L1072">                return finalOut;</span>
            } else {
                // System.err.println(&quot;No need to resize array.&quot;);
<span class="fc" id="L1075">                return outBuff;</span>
            }

        } // end else: don't compress

    } // end encodeBytesToBytes

    /* D E C O D I N G M E T H O D S */

    /**
     * Decodes four bytes from array &lt;var&gt;source&lt;/var&gt; and writes the resulting
     * bytes (up to three of them) to &lt;var&gt;destination&lt;/var&gt;. The source and
     * destination arrays can be manipulated anywhere along their length by
     * specifying &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;. This method
     * does not check to make sure your arrays are large enough to accomodate
     * &lt;var&gt;srcOffset&lt;/var&gt; + 4 for the &lt;var&gt;source&lt;/var&gt; array or
     * &lt;var&gt;destOffset&lt;/var&gt; + 3 for the &lt;var&gt;destination&lt;/var&gt; array. This
     * method returns the actual number of bytes that were converted from the
     * Base64 encoding.
     * &lt;p&gt;
     * This is the lowest level of the decoding methods with all possible
     * parameters.
     * &lt;/p&gt;
     *
     *
     * @param source
     *            the array to convert
     * @param srcOffset
     *            the index where conversion begins
     * @param destination
     *            the array to hold the conversion
     * @param destOffset
     *            the index where output will be put
     * @param options
     *            alphabet type is pulled from this (standard, url-safe,
     *            ordered)
     * @return the number of decoded bytes converted
     * @throws NullPointerException
     *             if source or destination arrays are null
     * @throws IllegalArgumentException
     *             if srcOffset or destOffset are invalid or there is not enough
     *             room in the array.
     * @since 1.3
     */
    private static int decode4to3(byte[] source, int srcOffset,
            byte[] destination, int destOffset, int options) {

        // Lots of error checking and exception throwing
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">        if (source == null) {</span>
<span class="nc" id="L1124">            throw new NullPointerException(&quot;Source array was null.&quot;);</span>
        } // end if
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">        if (destination == null) {</span>
<span class="nc" id="L1127">            throw new NullPointerException(&quot;Destination array was null.&quot;);</span>
        } // end if
<span class="pc bpc" id="L1129" title="2 of 4 branches missed.">        if (srcOffset &lt; 0 || srcOffset + 3 &gt;= source.length) {</span>
<span class="nc" id="L1130">            throw new IllegalArgumentException(</span>
                    String
<span class="nc" id="L1132">                            .format(</span>
                                    &quot;Source array with length %d cannot have offset of %d and still process four bytes.&quot;,
<span class="nc" id="L1134">                                    source.length, srcOffset));</span>
        } // end if
<span class="pc bpc" id="L1136" title="2 of 4 branches missed.">        if (destOffset &lt; 0 || destOffset + 2 &gt;= destination.length) {</span>
<span class="nc" id="L1137">            throw new IllegalArgumentException(</span>
                    String
<span class="nc" id="L1139">                            .format(</span>
                                    &quot;Destination array with length %d cannot have offset of %d and still store three bytes.&quot;,
<span class="nc" id="L1141">                                    destination.length, destOffset));</span>
        } // end if

<span class="fc" id="L1144">        byte[] DECODABET = getDecodabet(options);</span>

        // Example: Dk==
<span class="fc bfc" id="L1147" title="All 2 branches covered.">        if (source[srcOffset + 2] == EQUALS_SIGN) {</span>
            // Two ways to do the same thing. Don't know which way I like best.
            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 6
            // )
            // | ( ( DECODABET[ source[ srcOffset + 1] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 );
<span class="fc" id="L1152">            int outBuff = ((DECODABET[source[srcOffset]] &amp; 0xFF) &lt;&lt; 18)</span>
                    | ((DECODABET[source[srcOffset + 1]] &amp; 0xFF) &lt;&lt; 12);

<span class="fc" id="L1155">            destination[destOffset] = (byte) (outBuff &gt;&gt;&gt; 16);</span>
<span class="fc" id="L1156">            return 1;</span>
        }

        // Example: DkL=
<span class="fc bfc" id="L1160" title="All 2 branches covered.">        else if (source[srcOffset + 3] == EQUALS_SIGN) {</span>
            // Two ways to do the same thing. Don't know which way I like best.
            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 6
            // )
            // | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
            // | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 );
<span class="fc" id="L1166">            int outBuff = ((DECODABET[source[srcOffset]] &amp; 0xFF) &lt;&lt; 18)</span>
                    | ((DECODABET[source[srcOffset + 1]] &amp; 0xFF) &lt;&lt; 12)
                    | ((DECODABET[source[srcOffset + 2]] &amp; 0xFF) &lt;&lt; 6);

<span class="fc" id="L1170">            destination[destOffset] = (byte) (outBuff &gt;&gt;&gt; 16);</span>
<span class="fc" id="L1171">            destination[destOffset + 1] = (byte) (outBuff &gt;&gt;&gt; 8);</span>
<span class="fc" id="L1172">            return 2;</span>
        }

        // Example: DkLE
        else {
            // Two ways to do the same thing. Don't know which way I like best.
            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 6
            // )
            // | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
            // | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 )
            // | ( ( DECODABET[ source[ srcOffset + 3 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 24 );
<span class="fc" id="L1183">            int outBuff = ((DECODABET[source[srcOffset]] &amp; 0xFF) &lt;&lt; 18)</span>
                    | ((DECODABET[source[srcOffset + 1]] &amp; 0xFF) &lt;&lt; 12)
                    | ((DECODABET[source[srcOffset + 2]] &amp; 0xFF) &lt;&lt; 6)
                    | ((DECODABET[source[srcOffset + 3]] &amp; 0xFF));

<span class="fc" id="L1188">            destination[destOffset] = (byte) (outBuff &gt;&gt; 16);</span>
<span class="fc" id="L1189">            destination[destOffset + 1] = (byte) (outBuff &gt;&gt; 8);</span>
<span class="fc" id="L1190">            destination[destOffset + 2] = (byte) (outBuff);</span>

<span class="fc" id="L1192">            return 3;</span>
        }
    } // end decodeToBytes

    /**
     * Low-level access to decoding ASCII characters in the form of a byte
     * array. &lt;strong&gt;Ignores GUNZIP option, if it's set.&lt;/strong&gt; This is not
     * generally a recommended method, although it is used internally as part of
     * the decoding process. Special case: if len = 0, an empty array is
     * returned. Still, if you need more speed and reduced memory footprint (and
     * aren't gzipping), consider this method.
     *
     * @param source
     *            The Base64 encoded data
     * @return decoded data
     * @since 2.3.1
     */
    public static byte[] decode(byte[] source) {
<span class="nc" id="L1210">        byte[] decoded = null;</span>
        try {
<span class="nc" id="L1212">            decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);</span>
<span class="nc" id="L1213">        } catch (java.io.IOException ex) {</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">            assert false : &quot;IOExceptions only come from GZipping, which is turned off: &quot;</span>
<span class="nc" id="L1215">                    + ex.getMessage();</span>
<span class="nc" id="L1216">        }</span>
<span class="nc" id="L1217">        return decoded;</span>
    }

    /**
     * Low-level access to decoding ASCII characters in the form of a byte
     * array. &lt;strong&gt;Ignores GUNZIP option, if it's set.&lt;/strong&gt; This is not
     * generally a recommended method, although it is used internally as part of
     * the decoding process. Special case: if len = 0, an empty array is
     * returned. Still, if you need more speed and reduced memory footprint (and
     * aren't gzipping), consider this method.
     *
     * @param source
     *            The Base64 encoded data
     * @param off
     *            The offset of where to begin decoding
     * @param len
     *            The length of characters to decode
     * @param options
     *            Can specify options such as alphabet type to use
     * @return decoded data
     * @throws java.io.IOException
     *             If bogus characters exist in source data
     * @since 1.3
     */
    public static byte[] decode(byte[] source, int off, int len, int options)
            throws java.io.IOException {

        // Lots of error checking and exception throwing
<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">        if (source == null) {</span>
<span class="nc" id="L1246">            throw new NullPointerException(&quot;Cannot decode null source array.&quot;);</span>
        } // end if
<span class="pc bpc" id="L1248" title="2 of 4 branches missed.">        if (off &lt; 0 || off + len &gt; source.length) {</span>
<span class="nc" id="L1249">            throw new IllegalArgumentException(</span>
                    String
<span class="nc" id="L1251">                            .format(</span>
                                    &quot;Source array with length %d cannot have offset of %d and process %d bytes.&quot;,
<span class="nc" id="L1253">                                    source.length, off, len));</span>
        } // end if

<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">        if (len == 0) {</span>
<span class="nc" id="L1257">            return new byte[0];</span>
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">        } else if (len &lt; 4) {</span>
<span class="nc" id="L1259">            throw new IllegalArgumentException(</span>
                    &quot;Base64-encoded string must have at least four characters, but length specified was &quot;
                            + len);
        } // end if

<span class="fc" id="L1264">        byte[] DECODABET = getDecodabet(options);</span>

<span class="fc" id="L1266">        int len34 = len * 3 / 4; // Estimate on array size</span>
<span class="fc" id="L1267">        byte[] outBuff = new byte[len34]; // Upper limit on size of output</span>
<span class="fc" id="L1268">        int outBuffPosn = 0; // Keep track of where we're writing</span>

<span class="fc" id="L1270">        byte[] b4 = new byte[4]; // Four byte buffer from source, eliminating</span>
        // white space
<span class="fc" id="L1272">        int b4Posn = 0; // Keep track of four byte input buffer</span>
<span class="fc" id="L1273">        int i = 0; // Source array counter</span>
<span class="fc" id="L1274">        byte sbiCrop = 0; // Low seven bits (ASCII) of input</span>
<span class="fc" id="L1275">        byte sbiDecode = 0; // Special value from DECODABET</span>

<span class="fc bfc" id="L1277" title="All 2 branches covered.">        for (i = off; i &lt; off + len; i++) { // Loop through source</span>

<span class="fc" id="L1279">            sbiCrop = (byte) (source[i] &amp; 0x7f); // Only the low seven bits</span>
<span class="fc" id="L1280">            sbiDecode = DECODABET[sbiCrop]; // Special value</span>

            // White space, Equals sign, or legit Base64 character
            // Note the values such as -5 and -9 in the
            // DECODABETs at the top of the file.
<span class="pc bpc" id="L1285" title="1 of 2 branches missed.">            if (sbiDecode &gt;= WHITE_SPACE_ENC) {</span>
<span class="fc bfc" id="L1286" title="All 2 branches covered.">                if (sbiDecode &gt;= EQUALS_SIGN_ENC) {</span>
<span class="fc" id="L1287">                    b4[b4Posn++] = sbiCrop; // Save non-whitespace</span>
<span class="fc bfc" id="L1288" title="All 2 branches covered.">                    if (b4Posn &gt; 3) { // Time to decode?</span>
<span class="fc" id="L1289">                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn,</span>
                                options);
<span class="fc" id="L1291">                        b4Posn = 0;</span>

                        // If that was the equals sign, break out of 'for' loop
<span class="fc bfc" id="L1294" title="All 2 branches covered.">                        if (sbiCrop == EQUALS_SIGN) {</span>
<span class="fc" id="L1295">                            break;</span>
                        } // end if: equals sign
                    } // end if: quartet built
                } // end if: equals sign or better
            } // end if: white space, equals sign or better
            else {
                // There's a bad input character in the Base64 stream.
<span class="nc" id="L1302">                throw new java.io.IOException(String.format(</span>
                        &quot;Bad Base64 input character '%c' in array position %d&quot;,
<span class="nc" id="L1304">                        source[i], i));</span>
            } // end else:
        } // each input character

<span class="fc" id="L1308">        byte[] out = new byte[outBuffPosn];</span>
<span class="fc" id="L1309">        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);</span>
<span class="fc" id="L1310">        return out;</span>
    } // end decode

    /**
     * Decodes data from Base64 notation, automatically detecting
     * gzip-compressed data and decompressing it.
     *
     * @param s
     *            the string to decode
     * @return the decoded data
     * @throws java.io.IOException
     *             If there is a problem
     * @since 1.4
     */
    public static byte[] decode(String s) throws java.io.IOException {
<span class="fc" id="L1325">        return decode(s, NO_OPTIONS);</span>
    }

    /**
     * Decodes data from Base64 notation, automatically detecting
     * gzip-compressed data and decompressing it.
     *
     * @param s
     *            the string to decode
     * @param options
     *            encode options such as URL_SAFE
     * @return the decoded data
     * @throws java.io.IOException
     *             if there is an error
     * @throws NullPointerException
     *             if &lt;tt&gt;s&lt;/tt&gt; is null
     * @since 1.4
     */
    public static byte[] decode(String s, int options)
            throws java.io.IOException {

<span class="pc bpc" id="L1346" title="1 of 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1347">            throw new NullPointerException(&quot;Input string was null.&quot;);</span>
        } // end if

        byte[] bytes;
        try {
<span class="fc" id="L1352">            bytes = s.getBytes(PREFERRED_ENCODING);</span>
        } // end try
<span class="nc" id="L1354">        catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="nc" id="L1355">            bytes = s.getBytes();</span>
<span class="fc" id="L1356">        } // end catch</span>
        // &lt;/change&gt;

        // Decode
<span class="fc" id="L1360">        bytes = decode(bytes, 0, bytes.length, options);</span>

        // Check to see if it's gzip-compressed
        // GZIP Magic Two-Byte Number: 0x8b1f (35615)
<span class="pc bpc" id="L1364" title="1 of 2 branches missed.">        boolean dontGunzip = (options &amp; DONT_GUNZIP) != 0;</span>
<span class="pc bpc" id="L1365" title="3 of 6 branches missed.">        if ((bytes != null) &amp;&amp; (bytes.length &gt;= 4) &amp;&amp; (!dontGunzip)) {</span>

<span class="fc" id="L1367">            int head = ((int) bytes[0] &amp; 0xff) | ((bytes[1] &lt;&lt; 8) &amp; 0xff00);</span>
<span class="pc bpc" id="L1368" title="1 of 2 branches missed.">            if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {</span>
<span class="nc" id="L1369">                java.io.ByteArrayInputStream bais = null;</span>
<span class="nc" id="L1370">                java.util.zip.GZIPInputStream gzis = null;</span>
<span class="nc" id="L1371">                java.io.ByteArrayOutputStream baos = null;</span>
<span class="nc" id="L1372">                byte[] buffer = new byte[2048];</span>
<span class="nc" id="L1373">                int length = 0;</span>

                try {
<span class="nc" id="L1376">                    baos = new java.io.ByteArrayOutputStream();</span>
<span class="nc" id="L1377">                    bais = new java.io.ByteArrayInputStream(bytes);</span>
<span class="nc" id="L1378">                    gzis = new java.util.zip.GZIPInputStream(bais);</span>

<span class="nc bnc" id="L1380" title="All 2 branches missed.">                    while ((length = gzis.read(buffer)) &gt;= 0) {</span>
<span class="nc" id="L1381">                        baos.write(buffer, 0, length);</span>
                    } // end while: reading input

                    // No error? Get new bytes.
<span class="nc" id="L1385">                    bytes = baos.toByteArray();</span>

                } // end try
<span class="nc" id="L1388">                catch (java.io.IOException e) {</span>
<span class="nc" id="L1389">                    e.printStackTrace();</span>
                    // Just return originally-decoded bytes
                } // end catch
                finally {
                    try {
<span class="nc" id="L1394">                        baos.close();</span>
<span class="nc" id="L1395">                    } catch (Exception e) {</span>
<span class="nc" id="L1396">                    }</span>
                    try {
<span class="nc" id="L1398">                        gzis.close();</span>
<span class="nc" id="L1399">                    } catch (Exception e) {</span>
<span class="nc" id="L1400">                    }</span>
                    try {
<span class="nc" id="L1402">                        bais.close();</span>
<span class="nc" id="L1403">                    } catch (Exception e) {</span>
<span class="nc" id="L1404">                    }</span>
                } // end finally

            } // end if: gzipped
        } // end if: bytes.length &gt;= 2

<span class="fc" id="L1410">        return bytes;</span>
    } // end decode

    /**
     * Attempts to decode Base64 data and deserialize a Java Object within.
     * Returns &lt;tt&gt;null&lt;/tt&gt; if there was an error.
     *
     * @param encodedObject
     *            The Base64 data to decode
     * @return The decoded and deserialized object
     * @throws NullPointerException
     *             if encodedObject is null
     * @throws java.io.IOException
     *             if there is a general error
     * @throws ClassNotFoundException
     *             if the decoded object is of a class that cannot be found by
     *             the JVM
     * @since 1.5
     */
    public static Object decodeToObject(String encodedObject)
            throws java.io.IOException, java.lang.ClassNotFoundException {
<span class="nc" id="L1431">        return decodeToObject(encodedObject, NO_OPTIONS, null);</span>
    }

    /**
     * Attempts to decode Base64 data and deserialize a Java Object within.
     * Returns &lt;tt&gt;null&lt;/tt&gt; if there was an error. If &lt;tt&gt;loader&lt;/tt&gt; is not
     * null, it will be the class loader used when deserializing.
     *
     * @param encodedObject
     *            The Base64 data to decode
     * @param options
     *            Various parameters related to decoding
     * @param loader
     *            Optional class loader to use in deserializing classes.
     * @return The decoded and deserialized object
     * @throws NullPointerException
     *             if encodedObject is null
     * @throws java.io.IOException
     *             if there is a general error
     * @throws ClassNotFoundException
     *             if the decoded object is of a class that cannot be found by
     *             the JVM
     * @since 2.3.4
     */
    public static Object decodeToObject(String encodedObject, int options,
            final ClassLoader loader) throws java.io.IOException,
            java.lang.ClassNotFoundException {

        // Decode and gunzip if necessary
<span class="nc" id="L1460">        byte[] objBytes = decode(encodedObject, options);</span>

<span class="nc" id="L1462">        java.io.ByteArrayInputStream bais = null;</span>
<span class="nc" id="L1463">        java.io.ObjectInputStream ois = null;</span>
<span class="nc" id="L1464">        Object obj = null;</span>

        try {
<span class="nc" id="L1467">            bais = new java.io.ByteArrayInputStream(objBytes);</span>

            // If no custom class loader is provided, use Java's builtin OIS.
<span class="nc bnc" id="L1470" title="All 2 branches missed.">            if (loader == null) {</span>
<span class="nc" id="L1471">                ois = new java.io.ObjectInputStream(bais);</span>
            } // end if: no loader provided

            // Else make a customized object input stream that uses
            // the provided class loader.
            else {
<span class="nc" id="L1477">                ois = new java.io.ObjectInputStream(bais) {</span>
                    @Override
                    public Class&lt;?&gt; resolveClass(
                            java.io.ObjectStreamClass streamClass)
                            throws java.io.IOException, ClassNotFoundException {
<span class="nc" id="L1482">                        Class&lt;?&gt; c = Class.forName(streamClass.getName(), false,</span>
                                loader);
<span class="nc bnc" id="L1484" title="All 2 branches missed.">                        if (c == null) {</span>
<span class="nc" id="L1485">                            return super.resolveClass(streamClass);</span>
                        } else {
<span class="nc" id="L1487">                            return c; // Class loader knows of this class.</span>
                        } // end else: not null
                    } // end resolveClass
                }; // end ois
            } // end else: no custom class loader

<span class="nc" id="L1493">            obj = ois.readObject();</span>
        } // end try
<span class="nc" id="L1495">        catch (java.io.IOException e) {</span>
<span class="nc" id="L1496">            throw e; // Catch and throw in order to execute finally{}</span>
        } // end catch
<span class="nc" id="L1498">        catch (java.lang.ClassNotFoundException e) {</span>
<span class="nc" id="L1499">            throw e; // Catch and throw in order to execute finally{}</span>
        } // end catch
        finally {
            try {
<span class="nc" id="L1503">                bais.close();</span>
<span class="nc" id="L1504">            } catch (Exception e) {</span>
<span class="nc" id="L1505">            }</span>
            try {
<span class="nc" id="L1507">                ois.close();</span>
<span class="nc" id="L1508">            } catch (Exception e) {</span>
<span class="nc" id="L1509">            }</span>
        } // end finally

<span class="nc" id="L1512">        return obj;</span>
    } // end decodeObject

    /**
     * Convenience method for encoding data to a file.
     *
     * &lt;p&gt;
     * As of v 2.3, if there is a error, the method will throw an
     * java.io.IOException. &lt;b&gt;This is new to v2.3!&lt;/b&gt; In earlier versions, it
     * just returned false, but in retrospect that's a pretty poor way to handle
     * it.
     * &lt;/p&gt;
     *
     * @param dataToEncode
     *            byte array of data to encode in base64 form
     * @param filename
     *            Filename for saving encoded data
     * @throws java.io.IOException
     *             if there is an error
     * @throws NullPointerException
     *             if dataToEncode is null
     * @since 2.1
     */
    public static void encodeToFile(byte[] dataToEncode, String filename)
            throws java.io.IOException {

<span class="nc bnc" id="L1538" title="All 2 branches missed.">        if (dataToEncode == null) {</span>
<span class="nc" id="L1539">            throw new NullPointerException(&quot;Data to encode was null.&quot;);</span>
        } // end iff

<span class="nc" id="L1542">        Base64.OutputStream bos = null;</span>
        try {
<span class="nc" id="L1544">            bos = new Base64.OutputStream(</span>
                    new java.io.FileOutputStream(filename), Base64.ENCODE);
<span class="nc" id="L1546">            bos.write(dataToEncode);</span>
        } // end try
<span class="nc" id="L1548">        catch (java.io.IOException e) {</span>
<span class="nc" id="L1549">            throw e; // Catch and throw to execute finally{} block</span>
        } // end catch: java.io.IOException
        finally {
            try {
<span class="nc" id="L1553">                bos.close();</span>
<span class="nc" id="L1554">            } catch (Exception e) {</span>
<span class="nc" id="L1555">            }</span>
        } // end finally

<span class="nc" id="L1558">    } // end encodeToFile</span>

    /**
     * Convenience method for decoding data to a file.
     *
     * &lt;p&gt;
     * As of v 2.3, if there is a error, the method will throw an
     * java.io.IOException. &lt;b&gt;This is new to v2.3!&lt;/b&gt; In earlier versions, it
     * just returned false, but in retrospect that's a pretty poor way to handle
     * it.
     * &lt;/p&gt;
     *
     * @param dataToDecode
     *            Base64-encoded data as a string
     * @param filename
     *            Filename for saving decoded data
     * @throws java.io.IOException
     *             if there is an error
     * @since 2.1
     */
    public static void decodeToFile(String dataToDecode, String filename)
            throws java.io.IOException {

<span class="nc" id="L1581">        Base64.OutputStream bos = null;</span>
        try {
<span class="nc" id="L1583">            bos = new Base64.OutputStream(</span>
                    new java.io.FileOutputStream(filename), Base64.DECODE);
<span class="nc" id="L1585">            bos.write(dataToDecode.getBytes(PREFERRED_ENCODING));</span>
        } // end try
<span class="nc" id="L1587">        catch (java.io.IOException e) {</span>
<span class="nc" id="L1588">            throw e; // Catch and throw to execute finally{} block</span>
        } // end catch: java.io.IOException
        finally {
            try {
<span class="nc" id="L1592">                bos.close();</span>
<span class="nc" id="L1593">            } catch (Exception e) {</span>
<span class="nc" id="L1594">            }</span>
        } // end finally

<span class="nc" id="L1597">    } // end decodeToFile</span>

    /**
     * Convenience method for reading a base64-encoded file and decoding it.
     *
     * &lt;p&gt;
     * As of v 2.3, if there is a error, the method will throw an
     * java.io.IOException. &lt;b&gt;This is new to v2.3!&lt;/b&gt; In earlier versions, it
     * just returned false, but in retrospect that's a pretty poor way to handle
     * it.
     * &lt;/p&gt;
     *
     * @param filename
     *            Filename for reading encoded data
     * @return decoded byte array
     * @throws java.io.IOException
     *             if there is an error
     * @since 2.1
     */
    public static byte[] decodeFromFile(String filename)
            throws java.io.IOException {

<span class="nc" id="L1619">        byte[] decodedData = null;</span>
<span class="nc" id="L1620">        Base64.InputStream bis = null;</span>
        try {
            // Set up some useful variables
<span class="nc" id="L1623">            java.io.File file = new java.io.File(filename);</span>
<span class="nc" id="L1624">            byte[] buffer = null;</span>
<span class="nc" id="L1625">            int length = 0;</span>
<span class="nc" id="L1626">            int numBytes = 0;</span>

            // Check for size of file
<span class="nc bnc" id="L1629" title="All 2 branches missed.">            if (file.length() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L1630">                throw new java.io.IOException(</span>
                        &quot;File is too big for this convenience method (&quot;
<span class="nc" id="L1632">                                + file.length() + &quot; bytes).&quot;);</span>
            } // end if: file too big for int index
<span class="nc" id="L1634">            buffer = new byte[(int) file.length()];</span>

            // Open a stream
<span class="nc" id="L1637">            bis = new Base64.InputStream(new java.io.BufferedInputStream(</span>
                    new java.io.FileInputStream(file)), Base64.DECODE);

            // Read until done
<span class="nc bnc" id="L1641" title="All 2 branches missed.">            while ((numBytes = bis.read(buffer, length, 4096)) &gt;= 0) {</span>
<span class="nc" id="L1642">                length += numBytes;</span>
            } // end while

            // Save in a variable to return
<span class="nc" id="L1646">            decodedData = new byte[length];</span>
<span class="nc" id="L1647">            System.arraycopy(buffer, 0, decodedData, 0, length);</span>

        } // end try
<span class="nc" id="L1650">        catch (java.io.IOException e) {</span>
<span class="nc" id="L1651">            throw e; // Catch and release to execute finally{}</span>
        } // end catch: java.io.IOException
        finally {
            try {
<span class="nc" id="L1655">                bis.close();</span>
<span class="nc" id="L1656">            } catch (Exception e) {</span>
<span class="nc" id="L1657">            }</span>
        } // end finally

<span class="nc" id="L1660">        return decodedData;</span>
    } // end decodeFromFile

    /**
     * Convenience method for reading a binary file and base64-encoding it.
     *
     * &lt;p&gt;
     * As of v 2.3, if there is a error, the method will throw an
     * java.io.IOException. &lt;b&gt;This is new to v2.3!&lt;/b&gt; In earlier versions, it
     * just returned false, but in retrospect that's a pretty poor way to handle
     * it.
     * &lt;/p&gt;
     *
     * @param filename
     *            Filename for reading binary data
     * @return base64-encoded string
     * @throws java.io.IOException
     *             if there is an error
     * @since 2.1
     */
    public static String encodeFromFile(String filename)
            throws java.io.IOException {

<span class="nc" id="L1683">        String encodedData = null;</span>
<span class="nc" id="L1684">        Base64.InputStream bis = null;</span>
        try {
            // Set up some useful variables
<span class="nc" id="L1687">            java.io.File file = new java.io.File(filename);</span>
<span class="nc" id="L1688">            byte[] buffer = new byte[Math.max((int) (file.length() * 1.4), 40)]; // Need</span>
            // max()
            // for
            // math
            // on
            // small
            // files
            // (v2.2.1)
<span class="nc" id="L1696">            int length = 0;</span>
<span class="nc" id="L1697">            int numBytes = 0;</span>

            // Open a stream
<span class="nc" id="L1700">            bis = new Base64.InputStream(new java.io.BufferedInputStream(</span>
                    new java.io.FileInputStream(file)), Base64.ENCODE);

            // Read until done
<span class="nc bnc" id="L1704" title="All 2 branches missed.">            while ((numBytes = bis.read(buffer, length, 4096)) &gt;= 0) {</span>
<span class="nc" id="L1705">                length += numBytes;</span>
            } // end while

            // Save in a variable to return
<span class="nc" id="L1709">            encodedData = new String(buffer, 0, length,</span>
                    Base64.PREFERRED_ENCODING);

        } // end try
<span class="nc" id="L1713">        catch (java.io.IOException e) {</span>
<span class="nc" id="L1714">            throw e; // Catch and release to execute finally{}</span>
        } // end catch: java.io.IOException
        finally {
            try {
<span class="nc" id="L1718">                bis.close();</span>
<span class="nc" id="L1719">            } catch (Exception e) {</span>
<span class="nc" id="L1720">            }</span>
        } // end finally

<span class="nc" id="L1723">        return encodedData;</span>
    } // end encodeFromFile

    /**
     * Reads &lt;tt&gt;infile&lt;/tt&gt; and encodes it to &lt;tt&gt;outfile&lt;/tt&gt;.
     *
     * @param infile
     *            Input file
     * @param outfile
     *            Output file
     * @throws java.io.IOException
     *             if there is an error
     * @since 2.2
     */
    public static void encodeFileToFile(String infile, String outfile)
            throws java.io.IOException {

<span class="nc" id="L1740">        String encoded = Base64.encodeFromFile(infile);</span>
<span class="nc" id="L1741">        java.io.OutputStream out = null;</span>
        try {
<span class="nc" id="L1743">            out = new java.io.BufferedOutputStream(</span>
                    new java.io.FileOutputStream(outfile));
<span class="nc" id="L1745">            out.write(encoded.getBytes(&quot;US-ASCII&quot;)); // Strict, 7-bit output.</span>
        } // end try
<span class="nc" id="L1747">        catch (java.io.IOException e) {</span>
<span class="nc" id="L1748">            throw e; // Catch and release to execute finally{}</span>
        } // end catch
        finally {
            try {
<span class="nc" id="L1752">                out.close();</span>
<span class="nc" id="L1753">            } catch (Exception ex) {</span>
<span class="nc" id="L1754">            }</span>
        } // end finally
<span class="nc" id="L1756">    } // end encodeFileToFile</span>

    /**
     * Reads &lt;tt&gt;infile&lt;/tt&gt; and decodes it to &lt;tt&gt;outfile&lt;/tt&gt;.
     *
     * @param infile
     *            Input file
     * @param outfile
     *            Output file
     * @throws java.io.IOException
     *             if there is an error
     * @since 2.2
     */
    public static void decodeFileToFile(String infile, String outfile)
            throws java.io.IOException {

<span class="nc" id="L1772">        byte[] decoded = Base64.decodeFromFile(infile);</span>
<span class="nc" id="L1773">        java.io.OutputStream out = null;</span>
        try {
<span class="nc" id="L1775">            out = new java.io.BufferedOutputStream(</span>
                    new java.io.FileOutputStream(outfile));
<span class="nc" id="L1777">            out.write(decoded);</span>
        } // end try
<span class="nc" id="L1779">        catch (java.io.IOException e) {</span>
<span class="nc" id="L1780">            throw e; // Catch and release to execute finally{}</span>
        } // end catch
        finally {
            try {
<span class="nc" id="L1784">                out.close();</span>
<span class="nc" id="L1785">            } catch (Exception ex) {</span>
<span class="nc" id="L1786">            }</span>
        } // end finally
<span class="nc" id="L1788">    } // end decodeFileToFile</span>

    /* I N N E R C L A S S I N P U T S T R E A M */

    /**
     * A {@link Base64.InputStream} will read data from another
     * &lt;tt&gt;java.io.InputStream&lt;/tt&gt;, given in the constructor, and encode/decode
     * to/from Base64 notation on the fly.
     *
     * @see Base64
     * @since 1.3
     */
    public static class InputStream extends java.io.FilterInputStream {

        private boolean encode; // Encoding or decoding
        private int position; // Current position in the buffer
        private byte[] buffer; // Small buffer holding converted data
        private int bufferLength; // Length of buffer (3 or 4)
        private int numSigBytes; // Number of meaningful bytes in the buffer
        private int lineLength;
        private boolean breakLines; // Break lines at less than 80 characters
        private int options; // Record options used to create the stream.
        private byte[] decodabet; // Local copies to avoid extra method calls

        /**
         * Constructs a {@link Base64.InputStream} in DECODE mode.
         *
         * @param in
         *            the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read data.
         * @since 1.3
         */
        public InputStream(java.io.InputStream in) {
<span class="nc" id="L1820">            this(in, DECODE);</span>
<span class="nc" id="L1821">        } // end constructor</span>

        /**
         * Constructs a {@link Base64.InputStream} in either ENCODE or DECODE
         * mode.
         * &lt;p&gt;
         * Valid options:
         *
         * &lt;pre&gt;
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DO_BREAK_LINES: break lines at 76 characters
         *     (only meaningful when encoding)&amp;lt;/i&amp;gt;
         * &lt;/pre&gt;
         * &lt;p&gt;
         * Example: &lt;code&gt;new Base64.InputStream( in, Base64.DECODE )&lt;/code&gt;
         *
         *
         * @param in
         *            the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read data.
         * @param options
         *            Specified options
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DO_BREAK_LINES
         * @since 2.0
         */
        public InputStream(java.io.InputStream in, int options) {

<span class="fc" id="L1849">            super(in);</span>
<span class="fc" id="L1850">            this.options = options; // Record for later</span>
<span class="pc bpc" id="L1851" title="1 of 2 branches missed.">            this.breakLines = (options &amp; DO_BREAK_LINES) &gt; 0;</span>
<span class="pc bpc" id="L1852" title="1 of 2 branches missed.">            this.encode = (options &amp; ENCODE) &gt; 0;</span>
<span class="pc bpc" id="L1853" title="1 of 2 branches missed.">            this.bufferLength = encode ? 4 : 3;</span>
<span class="fc" id="L1854">            this.buffer = new byte[bufferLength];</span>
<span class="fc" id="L1855">            this.position = -1;</span>
<span class="fc" id="L1856">            this.lineLength = 0;</span>
<span class="fc" id="L1857">            this.decodabet = getDecodabet(options);</span>
<span class="fc" id="L1858">        } // end constructor</span>

        /**
         * Reads enough of the input stream to convert to/from Base64 and
         * returns the next byte.
         *
         * @return next byte
         * @since 1.3
         */
        @Override
        public int read() throws java.io.IOException {

            // Do we need to get data?
<span class="fc bfc" id="L1871" title="All 2 branches covered.">            if (position &lt; 0) {</span>
<span class="pc bpc" id="L1872" title="1 of 2 branches missed.">                if (encode) {</span>
<span class="nc" id="L1873">                    byte[] b3 = new byte[3];</span>
<span class="nc" id="L1874">                    int numBinaryBytes = 0;</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">                    for (int i = 0; i &lt; 3; i++) {</span>
<span class="nc" id="L1876">                        int b = in.read();</span>

                        // If end of stream, b is -1.
<span class="nc bnc" id="L1879" title="All 2 branches missed.">                        if (b &gt;= 0) {</span>
<span class="nc" id="L1880">                            b3[i] = (byte) b;</span>
<span class="nc" id="L1881">                            numBinaryBytes++;</span>
                        } else {
                            break; // out of for loop
                        } // end else: end of stream

                    } // end for: each needed input byte

<span class="nc bnc" id="L1888" title="All 2 branches missed.">                    if (numBinaryBytes &gt; 0) {</span>
<span class="nc" id="L1889">                        encode3to4(b3, 0, numBinaryBytes, buffer, 0, options);</span>
<span class="nc" id="L1890">                        position = 0;</span>
<span class="nc" id="L1891">                        numSigBytes = 4;</span>
                    } // end if: got data
                    else {
<span class="nc" id="L1894">                        return -1; // Must be end of stream</span>
                    } // end else
<span class="nc" id="L1896">                } // end if: encoding</span>

                // Else decoding
                else {
<span class="fc" id="L1900">                    byte[] b4 = new byte[4];</span>
<span class="fc" id="L1901">                    int i = 0;</span>
<span class="fc bfc" id="L1902" title="All 2 branches covered.">                    for (i = 0; i &lt; 4; i++) {</span>
                        // Read four &quot;meaningful&quot; bytes:
<span class="fc" id="L1904">                        int b = 0;</span>
                        do {
<span class="fc" id="L1906">                            b = in.read();</span>
<span class="pc bpc" id="L1907" title="1 of 4 branches missed.">                        } while (b &gt;= 0</span>
                                &amp;&amp; decodabet[b &amp; 0x7f] &lt;= WHITE_SPACE_ENC);

<span class="fc bfc" id="L1910" title="All 2 branches covered.">                        if (b &lt; 0) {</span>
<span class="fc" id="L1911">                            break; // Reads a -1 if end of stream</span>
                        } // end if: end of stream

<span class="fc" id="L1914">                        b4[i] = (byte) b;</span>
                    } // end for: each needed input byte

<span class="fc bfc" id="L1917" title="All 2 branches covered.">                    if (i == 4) {</span>
<span class="fc" id="L1918">                        numSigBytes = decode4to3(b4, 0, buffer, 0, options);</span>
<span class="fc" id="L1919">                        position = 0;</span>
                    } // end if: got four characters
<span class="pc bpc" id="L1921" title="1 of 2 branches missed.">                    else if (i == 0) {</span>
<span class="fc" id="L1922">                        return -1;</span>
                    } // end else if: also padded correctly
                    else {
                        // Must have broken out from above.
<span class="nc" id="L1926">                        throw new java.io.IOException(</span>
                                &quot;Improperly padded Base64 input.&quot;);
                    } // end

                } // end else: decode
            } // end else: get data

            // Got data?
<span class="pc bpc" id="L1934" title="1 of 2 branches missed.">            if (position &gt;= 0) {</span>
                // End of relevant data?
<span class="fc bfc" id="L1936" title="All 2 branches covered.">                if ( /* !encode &amp;&amp; */position &gt;= numSigBytes) {</span>
<span class="fc" id="L1937">                    return -1;</span>
                } // end if: got data

<span class="pc bpc" id="L1940" title="5 of 6 branches missed.">                if (encode &amp;&amp; breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH) {</span>
<span class="nc" id="L1941">                    lineLength = 0;</span>
<span class="nc" id="L1942">                    return '\n';</span>
                } // end if
                else {
<span class="fc" id="L1945">                    lineLength++; // This isn't important when decoding</span>
                    // but throwing an extra &quot;if&quot; seems
                    // just as wasteful.

<span class="fc" id="L1949">                    int b = buffer[position++];</span>

<span class="fc bfc" id="L1951" title="All 2 branches covered.">                    if (position &gt;= bufferLength) {</span>
<span class="fc" id="L1952">                        position = -1;</span>
                    } // end if: end

<span class="fc" id="L1955">                    return b &amp; 0xFF; // This is how you &quot;cast&quot; a byte that's</span>
                    // intended to be unsigned.
                } // end else
            } // end if: position &gt;= 0

            // Else error
            else {
<span class="nc" id="L1962">                throw new java.io.IOException(</span>
                        &quot;Error in Base64 code reading stream.&quot;);
            } // end else
        } // end read

        /**
         * Calls {@link #read()} repeatedly until the end of stream is reached
         * or &lt;var&gt;len&lt;/var&gt; bytes are read. Returns number of bytes read into
         * array or -1 if end of stream is encountered.
         *
         * @param dest
         *            array to hold values
         * @param off
         *            offset for array
         * @param len
         *            max number of bytes to read into array
         * @return bytes read into array or -1 if end of stream is encountered.
         * @since 1.3
         */
        @Override
        public int read(byte[] dest, int off, int len)
                throws java.io.IOException {
            int i;
            int b;
<span class="fc bfc" id="L1986" title="All 2 branches covered.">            for (i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1987">                b = read();</span>

<span class="fc bfc" id="L1989" title="All 2 branches covered.">                if (b &gt;= 0) {</span>
<span class="fc" id="L1990">                    dest[off + i] = (byte) b;</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">                } else if (i == 0) {</span>
<span class="fc" id="L1992">                    return -1;</span>
                } else {
                    break; // Out of 'for' loop
                } // Out of 'for' loop
            } // end for: each byte read
<span class="fc" id="L1997">            return i;</span>
        } // end read

    } // end inner class InputStream

    /* I N N E R C L A S S O U T P U T S T R E A M */

    /**
     * A {@link Base64.OutputStream} will write data to another
     * &lt;tt&gt;java.io.OutputStream&lt;/tt&gt;, given in the constructor, and
     * encode/decode to/from Base64 notation on the fly.
     *
     * @see Base64
     * @since 1.3
     */
    public static class OutputStream extends java.io.FilterOutputStream {

        private boolean encode;
        private int position;
        private byte[] buffer;
        private int bufferLength;
        private int lineLength;
        private boolean breakLines;
        private byte[] b4; // Scratch used in a few places
        private boolean suspendEncoding;
        private int options; // Record for later
        private byte[] decodabet; // Local copies to avoid extra method calls

        /**
         * Constructs a {@link Base64.OutputStream} in ENCODE mode.
         *
         * @param out
         *            the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be
         *            written.
         * @since 1.3
         */
        public OutputStream(java.io.OutputStream out) {
<span class="fc" id="L2034">            this(out, ENCODE);</span>
<span class="fc" id="L2035">        } // end constructor</span>

        /**
         * Constructs a {@link Base64.OutputStream} in either ENCODE or DECODE
         * mode.
         * &lt;p&gt;
         * Valid options:
         *
         * &lt;pre&gt;
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DO_BREAK_LINES: don't break lines at 76 characters
         *     (only meaningful when encoding)&amp;lt;/i&amp;gt;
         * &lt;/pre&gt;
         * &lt;p&gt;
         * Example: &lt;code&gt;new Base64.OutputStream( out, Base64.ENCODE )&lt;/code&gt;
         *
         * @param out
         *            the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be
         *            written.
         * @param options
         *            Specified options.
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DO_BREAK_LINES
         * @since 1.3
         */
        public OutputStream(java.io.OutputStream out, int options) {
<span class="fc" id="L2062">            super(out);</span>
<span class="pc bpc" id="L2063" title="1 of 2 branches missed.">            this.breakLines = (options &amp; DO_BREAK_LINES) != 0;</span>
<span class="pc bpc" id="L2064" title="1 of 2 branches missed.">            this.encode = (options &amp; ENCODE) != 0;</span>
<span class="pc bpc" id="L2065" title="1 of 2 branches missed.">            this.bufferLength = encode ? 3 : 4;</span>
<span class="fc" id="L2066">            this.buffer = new byte[bufferLength];</span>
<span class="fc" id="L2067">            this.position = 0;</span>
<span class="fc" id="L2068">            this.lineLength = 0;</span>
<span class="fc" id="L2069">            this.suspendEncoding = false;</span>
<span class="fc" id="L2070">            this.b4 = new byte[4];</span>
<span class="fc" id="L2071">            this.options = options;</span>
<span class="fc" id="L2072">            this.decodabet = getDecodabet(options);</span>
<span class="fc" id="L2073">        } // end constructor</span>

        /**
         * Writes the byte to the output stream after converting to/from Base64
         * notation. When encoding, bytes are buffered three at a time before
         * the output stream actually gets a write() call. When decoding, bytes
         * are buffered four at a time.
         *
         * @param theByte
         *            the byte to write
         * @since 1.3
         */
        @Override
        public void write(int theByte) throws java.io.IOException {
            // Encoding suspended?
<span class="pc bpc" id="L2088" title="1 of 2 branches missed.">            if (suspendEncoding) {</span>
<span class="nc" id="L2089">                this.out.write(theByte);</span>
<span class="nc" id="L2090">                return;</span>
            } // end if: supsended

            // Encode?
<span class="pc bpc" id="L2094" title="1 of 2 branches missed.">            if (encode) {</span>
<span class="fc" id="L2095">                buffer[position++] = (byte) theByte;</span>
<span class="fc bfc" id="L2096" title="All 2 branches covered.">                if (position &gt;= bufferLength) { // Enough to encode.</span>

<span class="fc" id="L2098">                    this.out</span>
<span class="fc" id="L2099">                            .write(encode3to4(b4, buffer, bufferLength, options));</span>

<span class="fc" id="L2101">                    lineLength += 4;</span>
<span class="pc bpc" id="L2102" title="3 of 4 branches missed.">                    if (breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH) {</span>
<span class="nc" id="L2103">                        this.out.write(NEW_LINE);</span>
<span class="nc" id="L2104">                        lineLength = 0;</span>
                    } // end if: end of line

<span class="fc" id="L2107">                    position = 0;</span>
                } // end if: enough to output
            } // end if: encoding

            // Else, Decoding
            else {
                // Meaningful Base64 character?
<span class="nc bnc" id="L2114" title="All 2 branches missed.">                if (decodabet[theByte &amp; 0x7f] &gt; WHITE_SPACE_ENC) {</span>
<span class="nc" id="L2115">                    buffer[position++] = (byte) theByte;</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">                    if (position &gt;= bufferLength) { // Enough to output.</span>

<span class="nc" id="L2118">                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);</span>
<span class="nc" id="L2119">                        out.write(b4, 0, len);</span>
<span class="nc" id="L2120">                        position = 0;</span>
<span class="nc" id="L2121">                    } // end if: enough to output</span>
                } // end if: meaningful base64 character
<span class="nc bnc" id="L2123" title="All 2 branches missed.">                else if (decodabet[theByte &amp; 0x7f] != WHITE_SPACE_ENC) {</span>
<span class="nc" id="L2124">                    throw new java.io.IOException(</span>
                            &quot;Invalid character in Base64 data.&quot;);
                } // end else: not white space either
            } // end else: decoding
<span class="fc" id="L2128">        } // end write</span>

        /**
         * Calls {@link #write(int)} repeatedly until &lt;var&gt;len&lt;/var&gt; bytes are
         * written.
         *
         * @param theBytes
         *            array from which to read bytes
         * @param off
         *            offset for array
         * @param len
         *            max number of bytes to read into array
         * @since 1.3
         */
        @Override
        public void write(byte[] theBytes, int off, int len)
                throws java.io.IOException {
            // Encoding suspended?
<span class="pc bpc" id="L2146" title="1 of 2 branches missed.">            if (suspendEncoding) {</span>
<span class="nc" id="L2147">                this.out.write(theBytes, off, len);</span>
<span class="nc" id="L2148">                return;</span>
            } // end if: supsended

<span class="fc bfc" id="L2151" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L2152">                write(theBytes[off + i]);</span>
            } // end for: each byte written

<span class="fc" id="L2155">        } // end write</span>

        /**
         * Method added by PHIL. [Thanks, PHIL. -Rob] This pads the buffer
         * without closing the stream.
         *
         * @throws java.io.IOException
         *             if there's an error.
         */
        public void flushBase64() throws java.io.IOException {
<span class="fc bfc" id="L2165" title="All 2 branches covered.">            if (position &gt; 0) {</span>
<span class="pc bpc" id="L2166" title="1 of 2 branches missed.">                if (encode) {</span>
<span class="fc" id="L2167">                    out.write(encode3to4(b4, buffer, position, options));</span>
<span class="fc" id="L2168">                    position = 0;</span>
                } // end if: encoding
                else {
<span class="nc" id="L2171">                    throw new java.io.IOException(</span>
                            &quot;Base64 input not properly padded.&quot;);
                } // end else: decoding
            } // end if: buffer partially full

<span class="fc" id="L2176">        } // end flush</span>

        /**
         * Flushes and closes (I think, in the superclass) the stream.
         *
         * @since 1.3
         */
        @Override
        public void close() throws java.io.IOException {
            // 1. Ensure that pending characters are written
<span class="fc" id="L2186">            flushBase64();</span>

            // 2. Actually close the stream
            // Base class both flushes and closes.
<span class="fc" id="L2190">            super.close();</span>

<span class="fc" id="L2192">            buffer = null;</span>
<span class="fc" id="L2193">            out = null;</span>
<span class="fc" id="L2194">        } // end close</span>

        /**
         * Suspends encoding of the stream. May be helpful if you need to embed
         * a piece of base64-encoded data in a stream.
         *
         * @throws java.io.IOException
         *             if there's an error flushing
         * @since 1.5.1
         */
        public void suspendEncoding() throws java.io.IOException {
<span class="nc" id="L2205">            flushBase64();</span>
<span class="nc" id="L2206">            this.suspendEncoding = true;</span>
<span class="nc" id="L2207">        } // end suspendEncoding</span>

        /**
         * Resumes encoding of the stream. May be helpful if you need to embed a
         * piece of base64-encoded data in a stream.
         *
         * @since 1.5.1
         */
        public void resumeEncoding() {
<span class="nc" id="L2216">            this.suspendEncoding = false;</span>
<span class="nc" id="L2217">        } // end resumeEncoding</span>

    } // end inner class OutputStream

} // end class Base64
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>