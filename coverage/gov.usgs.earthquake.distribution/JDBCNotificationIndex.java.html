<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JDBCNotificationIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.distribution</a> &gt; <span class="el_source">JDBCNotificationIndex.java</span></div><h1>JDBCNotificationIndex.java</h1><pre class="source lang-java linenums">/*
 * JDBCNotificationIndex
 */
package gov.usgs.earthquake.distribution;

import gov.usgs.earthquake.product.ProductId;
import gov.usgs.earthquake.util.JDBCConnection;
import gov.usgs.util.Config;
import gov.usgs.util.StreamUtils;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Logger;

/**
 * Stores and retrieves Notifications.
 *
 * This is typically used by a NotificationReceiver to track its Notifications,
 * but may also be used by NotificationListeners. Each object should maintain a
 * separate NotificationIndex.
 *
 * This implementation uses a SQLite Database as the index.
 *
 * @see gov.usgs.earthquake.distribution.NotificationIndex
 */
public class JDBCNotificationIndex extends JDBCConnection implements
		NotificationIndex {

<span class="fc" id="L39">	private static final Logger LOGGER = Logger</span>
<span class="fc" id="L40">			.getLogger(JDBCNotificationIndex.class.getName());</span>

	/**
	 * Default (empty) DB Schema SQLite file for the index. If the configured
	 * index file does not exist in the file system at the time this instance's
	 * &quot;startup()&quot; method is called, then this file is copied out of the JAR
	 * file into the file system as configured.
	 *
	 * The schema contained in this file is very simple:
	 *
	 * CREATE TABLE notification_index ( id INTEGER PRIMARY KEY NOT NULL,
	 * product_source TEXT NOT NULL, product_type TEXT NOT NULL, product_code
	 * TEXT NOT NULL, product_update LONG NOT NULL, expiration_date LONG NOT
	 * NULL, tracker_url TEXT NOT NULL, product_url TEXT );
	 *
	 * CREATE TABLE tmp_lookup_table ( product_source TEXT, product_type TEXT,
	 * product_code TEXT);
	 *
	 * CREATE INDEX expired_index on notification_index (expiration_date);
	 * CREATE INDEX id_index on notification_index (product_source,
	 * product_type, product_code, product_update);
	 *
	 * CREATE TABLE notification_queue ( id INTEGER PRIMARY KEY NOT NULL,
	 * queue_name TEXT NOT NULL, product_source TEXT NOT NULL, product_type TEXT
	 * NOT NULL, product_code TEXT NOT NULL, product_update LONG NOT NULL );
	 *
	 * CREATE INDEX queue_index on notification_queue (queue_name,
	 * product_source, product_type, product_code, product_update);
	 *
	 */
	private static final String JDBC_DB_SCHEMA = &quot;etc/schema/notificationIndex.db&quot;;

	// The following variables reference database information and are used for
	// binding/fetching query parameters in the prepared statements
	private static final String TABLE_NAME = &quot;notification_index&quot;;
	private static final String TMP_TABLE = &quot;tmp_lookup_table&quot;;
	private static final String ID_COLUMN = &quot;id&quot;;
	private static final String PRODUCT_SOURCE_COLUMN = &quot;product_source&quot;;
	private static final String PRODUCT_TYPE_COLUMN = &quot;product_type&quot;;
	private static final String PRODUCT_CODE_COLUMN = &quot;product_code&quot;;
	private static final String PRODUCT_UPDATE_COLUMN = &quot;product_update&quot;;
	private static final String EXPIRATION_DATE_COLUMN = &quot;expiration_date&quot;;
	private static final String TRACKER_URL_COLUMN = &quot;tracker_url&quot;;
	private static final String PRODUCT_URL_COLUMN = &quot;product_url&quot;;

	// SQLite driver information
	/** SQLite driver class name. */
	private static final String JDBC_DRIVER_CLASS = &quot;org.sqlite.JDBC&quot;;
	/** SQLite connect url without a filename. */
	private static final String JDBC_CONNECT_URL = &quot;jdbc:sqlite:&quot;;
	/** Default SQLite database filename. */
	private static final String JDBC_DEFAULT_FILE = &quot;pd_index.db&quot;;

	// This is the property key used in the configuration file to specify a
	// different SQLite database file. If this file doesn't exist it will be
	// created at startup time
	protected static final String JDBC_FILE_PROPERTY = &quot;indexfile&quot;;

	/** SQL stub for adding a notification to the index. */
<span class="fc" id="L99">	private static final String DML_ADD_NOTIFICATION = String.format(</span>
			&quot;INSERT INTO %s (%s, %s, %s, %s, %s, %s, %s) VALUES &quot;
					+ &quot;(?, ?, ?, ?, ?, ?, ?)&quot;, TABLE_NAME,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN);

	/** SQL stub for removing a notification from the index. */
<span class="fc" id="L107">	private static final String DML_REMOVE_NOTIFICATION = String.format(</span>
			&quot;DELETE FROM %s WHERE %s = ? AND %s = ? AND %s = ? &quot;
					+ &quot;AND %s = ? AND %s = ? AND %s = ? AND %s = ?&quot;,
			TABLE_NAME, PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN,
			PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
			TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN);

	/** SQL stub for finding expired notifications. */
<span class="fc" id="L115">	private static final String QUERY_FIND_EXPIRED_NOTIFICATIONS = String</span>
<span class="fc" id="L116">			.format(&quot;SELECT %s, %s, %s, %s, %s, %s, %s, %s FROM %s &quot;</span>
					+ &quot;WHERE %s &lt;= ?&quot;, ID_COLUMN, PRODUCT_SOURCE_COLUMN,
					PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
					PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
					TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
					EXPIRATION_DATE_COLUMN);

	/** SQL stub for finding notifications about a particular productId */
<span class="fc" id="L124">	private static final String QUERY_FIND_NOTIFICATIONS_BY_ID = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s, %s FROM %s &quot;
					+ &quot;WHERE %s = ? AND %s = ? AND %s = ? AND %s = ?&quot;,
			ID_COLUMN, PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN,
			PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
			TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN);

	/**
	 * SQL stub for finding notifications about products based on discrete data.
	 */
<span class="fc" id="L136">	private static final String QUERY_FIND_NOTIFICATIONS_BY_DATA = String</span>
<span class="fc" id="L137">			.format(&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE &quot;</span>
					+ &quot;UPPER(%s) LIKE ? AND UPPER(%s) LIKE ? AND &quot;
					+ &quot;UPPER(%s) LIKE ?&quot;, PRODUCT_SOURCE_COLUMN,
					PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
					PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
					TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
					PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN,
					PRODUCT_CODE_COLUMN);

	/** Name of the SQLite DB file to use. This is configurable. */
<span class="fc" id="L147">	private String _jdbc_index_file = null;</span>

	/**
	 * Connection URL. Created from the JDBC_CONNET_URL and configured index
	 * file.
	 */
<span class="fc" id="L153">	private String _jdbc_connect_url = null;</span>

	// These are the prepared statements we will use for all DB interactions. //

<span class="fc" id="L157">	private PreparedStatement _dml_addNotification = null;</span>
<span class="fc" id="L158">	private PreparedStatement _dml_removeNotification = null;</span>

<span class="fc" id="L160">	private PreparedStatement _query_findExpiredNotifications = null;</span>
<span class="fc" id="L161">	private PreparedStatement _query_findNotificationsById = null;</span>
<span class="fc" id="L162">	private PreparedStatement _query_findNotificationsByData = null;</span>

	// Stubs used in the list version of find by data method. //
<span class="fc" id="L165">	private static final String DML_CREATE_TMP_TABLE = String.format(</span>
			&quot;CREATE TABLE IF NOT EXISTS %s (%s TEXT, %s TEXT, %s TEXT)&quot;,
			TMP_TABLE, PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN,
			PRODUCT_CODE_COLUMN);
<span class="fc" id="L169">	private static final String DML_ADD_TMP_SOURCE = String.format(</span>
			&quot;INSERT INTO %s (%s) VALUES (?)&quot;, TMP_TABLE, PRODUCT_SOURCE_COLUMN);
<span class="fc" id="L171">	private static final String DML_ADD_TMP_TYPE = String.format(</span>
			&quot;INSERT INTO %s (%s) VALUES (?)&quot;, TMP_TABLE, PRODUCT_TYPE_COLUMN);
<span class="fc" id="L173">	private static final String DML_ADD_TMP_CODE = String.format(</span>
			&quot;INSERT INTO %s (%s) VALUES (?)&quot;, TMP_TABLE, PRODUCT_CODE_COLUMN);

<span class="fc" id="L176">	private static final String QUERY_SEARCH_BY_SOURCE_TYPE_CODE = String</span>
<span class="fc" id="L177">			.format(&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;</span>
					+ &quot;(SELECT %s FROM %s) AND %s IN (SELECT %s FROM %s) AND &quot;
					+ &quot;%s IN (SELECT %s FROM %s)&quot;, PRODUCT_SOURCE_COLUMN,
					PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
					PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
					TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
					PRODUCT_SOURCE_COLUMN, PRODUCT_SOURCE_COLUMN, TMP_TABLE,
					PRODUCT_TYPE_COLUMN, PRODUCT_TYPE_COLUMN, TMP_TABLE,
					PRODUCT_CODE_COLUMN, PRODUCT_CODE_COLUMN, TMP_TABLE);

<span class="fc" id="L187">	private static final String QUERY_SEARCH_BY_SOURCE_TYPE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s) AND %s IN (SELECT %s FROM %s)&quot;,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN, TABLE_NAME, PRODUCT_SOURCE_COLUMN,
			PRODUCT_SOURCE_COLUMN, TMP_TABLE, PRODUCT_TYPE_COLUMN,
			PRODUCT_TYPE_COLUMN, TMP_TABLE);

<span class="fc" id="L196">	private static final String QUERY_SEARCH_BY_SOURCE_CODE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s) AND %s IN (SELECT %s FROM %s)&quot;,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN, TABLE_NAME, PRODUCT_SOURCE_COLUMN,
			PRODUCT_SOURCE_COLUMN, TMP_TABLE, PRODUCT_CODE_COLUMN,
			PRODUCT_CODE_COLUMN, TMP_TABLE);

<span class="fc" id="L205">	private static final String QUERY_SEARCH_BY_TYPE_CODE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s) AND %s IN (SELECT %s FROM %s)&quot;,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN, TABLE_NAME, PRODUCT_TYPE_COLUMN,
			PRODUCT_TYPE_COLUMN, TMP_TABLE, PRODUCT_CODE_COLUMN,
			PRODUCT_CODE_COLUMN, TMP_TABLE);

<span class="fc" id="L214">	private static final String QUERY_SEARCH_BY_SOURCE = String</span>
<span class="fc" id="L215">			.format(&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;</span>
					+ &quot;(SELECT %s FROM %s)&quot;, PRODUCT_SOURCE_COLUMN,
					PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
					PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
					TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
					PRODUCT_SOURCE_COLUMN, PRODUCT_SOURCE_COLUMN, TMP_TABLE);

<span class="fc" id="L222">	private static final String QUERY_SEARCH_BY_TYPE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s)&quot;, PRODUCT_SOURCE_COLUMN,
			PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN,
			EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN,
			TABLE_NAME, PRODUCT_TYPE_COLUMN, PRODUCT_TYPE_COLUMN, TMP_TABLE);

<span class="fc" id="L229">	private static final String QUERY_SEARCH_BY_CODE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s)&quot;, PRODUCT_SOURCE_COLUMN,
			PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN,
			EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN,
			TABLE_NAME, PRODUCT_CODE_COLUMN, PRODUCT_CODE_COLUMN, TMP_TABLE);
	/*
	 * private static final String QUERY_ALL_NOTIFICATIONS = String.format(
	 * &quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s&quot;, PRODUCT_SOURCE_COLUMN,
	 * PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN,
	 * EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN,
	 * TABLE_NAME);
	 */

<span class="fc" id="L243">	private static final String QUERY_LATEST_NOTIFICATIONS = String.format(</span>
			&quot;SELECT n.%s, n.%s, n.%s, n.%s, n.%s, n.%s, n.%s FROM %s n, &quot;
					+ &quot;(select max(id) as id, product_source, product_type, &quot;
					+ &quot;product_code, product_update from notification_index &quot;
					+ &quot;group by product_source, product_type, product_code, &quot;
					+ &quot;product_update) latest where n.id=latest.id &quot;
					+ &quot; order by n.product_update asc&quot;,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN, TABLE_NAME);

	// These are for searching the DB index by specific parameters. */
<span class="fc" id="L255">	private PreparedStatement _dml_createTmpTable = null;</span>
<span class="fc" id="L256">	private PreparedStatement _dml_addTmpSource = null;</span>
<span class="fc" id="L257">	private PreparedStatement _dml_addTmpType = null;</span>
<span class="fc" id="L258">	private PreparedStatement _dml_addTmpCode = null;</span>

<span class="fc" id="L260">	private PreparedStatement _query_searchBySourceTypeCode = null;</span>
<span class="fc" id="L261">	private PreparedStatement _query_searchBySourceType = null;</span>
<span class="fc" id="L262">	private PreparedStatement _query_searchBySourceCode = null;</span>
<span class="fc" id="L263">	private PreparedStatement _query_searchByTypeCode = null;</span>
<span class="fc" id="L264">	private PreparedStatement _query_searchBySource = null;</span>
<span class="fc" id="L265">	private PreparedStatement _query_searchByType = null;</span>
<span class="fc" id="L266">	private PreparedStatement _query_searchByCode = null;</span>
<span class="fc" id="L267">	private PreparedStatement _query_getAllNotifications = null;</span>

	/**
	 * Default, no-arg constructor. This just ensures the JDBC SQLite driver is
	 * appropriately on the classpath for proper runtime execution. This
	 * probably will not get called directly in favor of the configurable
	 * constructor.
	 *
	 * @throws Exception
	 *             If the JDBC driver class is not found.
	 * @see #JDBC_DRIVER_CLASS
	 */
	public JDBCNotificationIndex() throws Exception {
<span class="fc" id="L280">		this((String) null);</span>
<span class="fc" id="L281">	}</span>

<span class="fc" id="L283">	public JDBCNotificationIndex(final String filename) throws Exception {</span>
<span class="fc" id="L284">		Class.forName(JDBC_DRIVER_CLASS);</span>
<span class="fc" id="L285">		_jdbc_index_file = filename;</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">		if (_jdbc_index_file == null) {</span>
<span class="fc" id="L287">			_jdbc_index_file = JDBC_DEFAULT_FILE;</span>
		}
<span class="fc" id="L289">		_jdbc_connect_url = JDBC_CONNECT_URL + _jdbc_index_file;</span>
<span class="fc" id="L290">	}</span>

	/**
	 * Constructor called from the config object conforming to the
	 * &lt;code&gt;Configurable&lt;/code&gt; interface specification. This internally calls
	 * its no-arg constructor then configures itself.
	 *
	 * @param config
	 *            The config object from which this instance will be configured.
	 * @throws Exception
	 *             If the JDBC driver class is not found.
	 * @see gov.usgs.util.Configurable
	 * @see #JDBC_DRIVER_CLASS
	 */
	public JDBCNotificationIndex(Config config) throws Exception {
<span class="fc" id="L305">		this();</span>
<span class="fc" id="L306">		this.configure(config);</span>
<span class="fc" id="L307">	}</span>

	/**
	 * Reads the given &lt;code&gt;config&lt;/code&gt; object and sets values appropriately.
	 *
	 * @param config
	 *            The config object from which this instance will be configured.
	 * @see gov.usgs.util.Configurable
	 */
	public void configure(Config config) throws Exception {
<span class="fc" id="L317">		_jdbc_index_file = config.getProperty(JDBC_FILE_PROPERTY);</span>
<span class="pc bpc" id="L318" title="2 of 4 branches missed.">		if (_jdbc_index_file == null || &quot;&quot;.equals(_jdbc_index_file)) {</span>
<span class="nc" id="L319">			_jdbc_index_file = JDBC_DEFAULT_FILE;</span>
		}
<span class="fc" id="L321">		LOGGER.config(&quot;Notification index database is '&quot; + _jdbc_index_file</span>
				+ &quot;'&quot;);
<span class="fc" id="L323">		_jdbc_connect_url = JDBC_CONNECT_URL + _jdbc_index_file;</span>
<span class="fc" id="L324">	}</span>

	@Override
	protected Connection connect() throws Exception {
		// Make sure file exists or copy it out of the JAR
<span class="fc" id="L329">		File indexFile = new File(_jdbc_index_file);</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">		if (!indexFile.exists()) {</span>
			// extract schema from jar
<span class="fc" id="L332">			URL schemaURL = JDBCNotificationIndex.class.getClassLoader()</span>
<span class="fc" id="L333">					.getResource(JDBC_DB_SCHEMA);</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">			if (schemaURL == null) {</span>
<span class="fc" id="L335">				schemaURL = new File(JDBC_DB_SCHEMA).toURI().toURL();</span>
			}
<span class="fc" id="L337">			StreamUtils.transferStream(schemaURL, indexFile);</span>
		}

<span class="fc" id="L340">		return DriverManager.getConnection(_jdbc_connect_url);</span>
	}

	/**
	 * Connects to the JDBC DB index and prepares the DML/Query statements that
	 * will execute at runtime. If the JDBC DB index file does not exist then an
	 * empty schema will be copied out of the executing JAR file to be used.
	 *
	 * @see gov.usgs.util.Configurable
	 */
	public void startup() throws Exception {
		// call super startup to connect
<span class="fc" id="L352">		super.startup();</span>
<span class="fc" id="L353">		Connection conn = getConnection();</span>

		// prepare statements
<span class="fc" id="L356">		_dml_addNotification = conn.prepareStatement(DML_ADD_NOTIFICATION);</span>
<span class="fc" id="L357">		_dml_removeNotification = conn</span>
<span class="fc" id="L358">				.prepareStatement(DML_REMOVE_NOTIFICATION);</span>

<span class="fc" id="L360">		_query_findExpiredNotifications = conn</span>
<span class="fc" id="L361">				.prepareStatement(QUERY_FIND_EXPIRED_NOTIFICATIONS);</span>
<span class="fc" id="L362">		_query_findNotificationsById = conn</span>
<span class="fc" id="L363">				.prepareStatement(QUERY_FIND_NOTIFICATIONS_BY_ID);</span>
<span class="fc" id="L364">		_query_findNotificationsByData = conn</span>
<span class="fc" id="L365">				.prepareStatement(QUERY_FIND_NOTIFICATIONS_BY_DATA);</span>

<span class="fc" id="L367">		_dml_createTmpTable = conn.prepareStatement(DML_CREATE_TMP_TABLE);</span>
<span class="fc" id="L368">		_dml_addTmpSource = conn.prepareStatement(DML_ADD_TMP_SOURCE);</span>
<span class="fc" id="L369">		_dml_addTmpType = conn.prepareStatement(DML_ADD_TMP_TYPE);</span>
<span class="fc" id="L370">		_dml_addTmpCode = conn.prepareStatement(DML_ADD_TMP_CODE);</span>

<span class="fc" id="L372">		_query_searchBySourceTypeCode = conn</span>
<span class="fc" id="L373">				.prepareStatement(QUERY_SEARCH_BY_SOURCE_TYPE_CODE);</span>
<span class="fc" id="L374">		_query_searchBySourceType = conn</span>
<span class="fc" id="L375">				.prepareStatement(QUERY_SEARCH_BY_SOURCE_TYPE);</span>
<span class="fc" id="L376">		_query_searchBySourceCode = conn</span>
<span class="fc" id="L377">				.prepareStatement(QUERY_SEARCH_BY_SOURCE_CODE);</span>
<span class="fc" id="L378">		_query_searchByTypeCode = conn</span>
<span class="fc" id="L379">				.prepareStatement(QUERY_SEARCH_BY_TYPE_CODE);</span>
<span class="fc" id="L380">		_query_searchBySource = conn.prepareStatement(QUERY_SEARCH_BY_SOURCE);</span>
<span class="fc" id="L381">		_query_searchByType = conn.prepareStatement(QUERY_SEARCH_BY_TYPE);</span>
<span class="fc" id="L382">		_query_searchByCode = conn.prepareStatement(QUERY_SEARCH_BY_CODE);</span>
<span class="fc" id="L383">		_query_getAllNotifications = conn</span>
<span class="fc" id="L384">				.prepareStatement(QUERY_LATEST_NOTIFICATIONS);</span>

<span class="fc" id="L386">	}</span>

	/**
	 * Closes the JDBC connection and all it's associated prepared statements.
	 *
	 * @see gov.usgs.util.Configurable
	 */
	public synchronized void shutdown() throws Exception {
		// Close the DML statements
		try {
<span class="fc" id="L396">			_dml_addNotification.close();</span>
<span class="fc" id="L397">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L399">			_dml_addNotification = null;</span>
		}
		try {
<span class="fc" id="L402">			_dml_removeNotification.close();</span>
<span class="fc" id="L403">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L405">			_dml_removeNotification = null;</span>
		}
		try {
<span class="fc" id="L408">			_dml_createTmpTable.close();</span>
<span class="fc" id="L409">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L411">			_dml_createTmpTable = null;</span>
		}
		try {
<span class="fc" id="L414">			_dml_addTmpSource.close();</span>
<span class="fc" id="L415">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L417">			_dml_addTmpSource = null;</span>
		}
		try {
<span class="fc" id="L420">			_dml_addTmpType.close();</span>
<span class="fc" id="L421">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L423">			_dml_addTmpType = null;</span>
		}
		try {
<span class="fc" id="L426">			_dml_addTmpCode.close();</span>
<span class="fc" id="L427">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L429">			_dml_addTmpCode = null;</span>
		}

		// Close the query statements
		try {
<span class="fc" id="L434">			_query_findExpiredNotifications.close();</span>
<span class="fc" id="L435">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L437">			_query_findExpiredNotifications = null;</span>
		}
		try {
<span class="fc" id="L440">			_query_findNotificationsById.close();</span>
<span class="fc" id="L441">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L443">			_query_findNotificationsById = null;</span>
		}
		try {
<span class="fc" id="L446">			_query_findNotificationsByData.close();</span>
<span class="fc" id="L447">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L449">			_query_findNotificationsByData = null;</span>
		}
		try {
<span class="fc" id="L452">			_query_searchBySourceTypeCode.close();</span>
<span class="fc" id="L453">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L455">			_query_searchBySourceTypeCode = null;</span>
		}
		try {
<span class="fc" id="L458">			_query_searchBySourceType.close();</span>
<span class="fc" id="L459">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L461">			_query_searchBySourceType = null;</span>
		}
		try {
<span class="fc" id="L464">			_query_searchBySourceCode.close();</span>
<span class="fc" id="L465">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L467">			_query_searchBySourceCode = null;</span>
		}
		try {
<span class="fc" id="L470">			_query_searchByTypeCode.close();</span>
<span class="fc" id="L471">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L473">			_query_searchByTypeCode = null;</span>
		}
		try {
<span class="fc" id="L476">			_query_searchBySource.close();</span>
<span class="fc" id="L477">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L479">			_query_searchBySource = null;</span>
		}
		try {
<span class="fc" id="L482">			_query_searchByType.close();</span>
<span class="fc" id="L483">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L485">			_query_searchByType = null;</span>
		}
		try {
<span class="fc" id="L488">			_query_searchByCode.close();</span>
<span class="fc" id="L489">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L491">			_query_searchByCode = null;</span>
		}
		try {
<span class="fc" id="L494">			_query_getAllNotifications.close();</span>
<span class="fc" id="L495">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L497">			_query_getAllNotifications = null;</span>
		}

		// call super shutdown to disconnect
<span class="fc" id="L501">		super.shutdown();</span>
<span class="fc" id="L502">	}</span>

	/**
	 * Add a notification to the index.
	 *
	 * If an identical notification is already in the index, the implementation
	 * may choose whether or not to store the duplicate information.
	 *
	 * @param notification
	 *            the notification to add.
	 * @throws Exception
	 *             if an error occurs while storing the notification.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized void addNotification(Notification notification)
			throws Exception {
		// verify connection
<span class="fc" id="L519">		this.verifyConnection();</span>

		// Read the product id from the notification
<span class="fc" id="L522">		ProductId productId = notification.getProductId();</span>

		// Parse the update date from the product id
<span class="fc" id="L525">		java.sql.Date updateDate = new java.sql.Date(productId.getUpdateTime()</span>
<span class="fc" id="L526">				.getTime());</span>

		// Parse the expiration date from the notification
<span class="fc" id="L529">		java.sql.Date expirationDate = new java.sql.Date(notification</span>
<span class="fc" id="L530">				.getExpirationDate().getTime());</span>

		// Read the URL value from the notification
<span class="fc" id="L533">		String trackerUrl = notification.getTrackerURL().toString();</span>

		// Set the values we parsed above
<span class="fc" id="L536">		_dml_addNotification.setString(1, productId.getSource());</span>
<span class="fc" id="L537">		_dml_addNotification.setString(2, productId.getType());</span>
<span class="fc" id="L538">		_dml_addNotification.setString(3, productId.getCode());</span>
<span class="fc" id="L539">		_dml_addNotification.setDate(4, updateDate);</span>
<span class="fc" id="L540">		_dml_addNotification.setDate(5, expirationDate);</span>
<span class="fc" id="L541">		_dml_addNotification.setString(6, trackerUrl);</span>

		// If this is a URL notification, set the product URL value as well
<span class="fc bfc" id="L544" title="All 2 branches covered.">		if (notification instanceof URLNotification) {</span>
<span class="fc" id="L545">			String productUrl = ((URLNotification) notification)</span>
<span class="fc" id="L546">					.getProductURL().toString();</span>
<span class="fc" id="L547">			_dml_addNotification.setString(7, productUrl);</span>
<span class="fc" id="L548">		} else {</span>
<span class="fc" id="L549">			_dml_addNotification.setString(7, &quot;&quot;);</span>
		}

		// already verified above
<span class="fc" id="L553">		Connection conn = getConnection();</span>
		try {
			// Begin a transaction
<span class="fc" id="L556">			conn.setAutoCommit(false);</span>
			// Execute the query
<span class="fc" id="L558">			_dml_addNotification.executeUpdate();</span>
			// Commit the changes
<span class="fc" id="L560">			conn.setAutoCommit(true);</span>
<span class="nc" id="L561">		} catch (SQLException sqx) {</span>
			// Undo any changes that may be in an unknown state. Ignore
			// exceptions that occur in this call since we're already throwing
			// an exception
			try {
<span class="nc" id="L566">				conn.rollback();</span>
<span class="nc" id="L567">			} catch (SQLException ex) {</span>
<span class="nc" id="L568">			}</span>

			// Re-throw this exception
<span class="nc" id="L571">			throw sqx;</span>
		} finally {
<span class="fc" id="L573">			conn.setAutoCommit(true);</span>
		}
<span class="fc" id="L575">	}</span>

	/**
	 * Remove a notification from the index.
	 *
	 * All matching notifications should be removed from the index.
	 *
	 * @param notification
	 *            the notification to remove.
	 * @throws Exception
	 *             if an error occurs while removing the notification.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized void removeNotification(Notification notification)
			throws Exception {
		// verify connection
<span class="fc" id="L591">		this.verifyConnection();</span>

		// Read the product id from the notification
<span class="fc" id="L594">		ProductId productId = notification.getProductId();</span>
		// Parse the update date from the product id
<span class="fc" id="L596">		java.sql.Date updateDate = new java.sql.Date(productId.getUpdateTime()</span>
<span class="fc" id="L597">				.getTime());</span>
		// Parse the expiration date from the notification
<span class="fc" id="L599">		java.sql.Date expirationDate = new java.sql.Date(notification</span>
<span class="fc" id="L600">				.getExpirationDate().getTime());</span>
		// Read the URL value from the notification
<span class="fc" id="L602">		String trackerUrl = notification.getTrackerURL().toString();</span>

		// Set the values we parsed above
<span class="fc" id="L605">		_dml_removeNotification.setString(1, productId.getSource());</span>
<span class="fc" id="L606">		_dml_removeNotification.setString(2, productId.getType());</span>
<span class="fc" id="L607">		_dml_removeNotification.setString(3, productId.getCode());</span>
<span class="fc" id="L608">		_dml_removeNotification.setDate(4, updateDate);</span>
<span class="fc" id="L609">		_dml_removeNotification.setDate(5, expirationDate);</span>
<span class="fc" id="L610">		_dml_removeNotification.setString(6, trackerUrl);</span>

		// If this is a URL notification, set the product URL value as well
<span class="fc bfc" id="L613" title="All 2 branches covered.">		if (notification instanceof URLNotification) {</span>
<span class="fc" id="L614">			String productUrl = ((URLNotification) notification)</span>
<span class="fc" id="L615">					.getProductURL().toString();</span>
<span class="fc" id="L616">			_dml_removeNotification.setString(7, productUrl);</span>
<span class="fc" id="L617">		} else {</span>
			// _dml_removeNotification.setNull(7, java.sql.Types.VARCHAR);
<span class="fc" id="L619">			_dml_removeNotification.setString(7, &quot;&quot;);</span>
		}

		// already verified above
<span class="fc" id="L623">		Connection conn = getConnection();</span>
		try {
			// Begin a transaction
<span class="fc" id="L626">			conn.setAutoCommit(false);</span>
			// Execute the query
<span class="fc" id="L628">			_dml_removeNotification.executeUpdate();</span>
			// Commit the changes
<span class="fc" id="L630">			conn.setAutoCommit(true);</span>
<span class="nc" id="L631">		} catch (SQLException sqx) {</span>
			// Undo any changes that may be in an unknown state. Ignore
			// exceptions that occur in this call since we're already throwing
			// an exception
			try {
<span class="nc" id="L636">				conn.rollback();</span>
<span class="nc" id="L637">			} catch (SQLException ex) {</span>
<span class="nc" id="L638">			}</span>
			// Re-throw this exception
<span class="nc" id="L640">			throw sqx;</span>
		} finally {
<span class="fc" id="L642">			conn.setAutoCommit(true);</span>
		}
<span class="fc" id="L644">	}</span>

	/**
	 * Search the index for notifications matching id.
	 *
	 * If more than one notification matches, all should be returned.
	 *
	 * @param id
	 *            the ProductId to find.
	 * @return a list of matching notifications.
	 * @throws Exception
	 *             if an error occurs while searching the index.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized List&lt;Notification&gt; findNotifications(ProductId id)
			throws Exception {
		// verify connection
<span class="fc" id="L661">		this.verifyConnection();</span>

<span class="fc" id="L663">		String source = id.getSource();</span>
<span class="fc" id="L664">		String type = id.getType();</span>
<span class="fc" id="L665">		String code = id.getCode();</span>
<span class="fc" id="L666">		java.sql.Date update = new java.sql.Date(id.getUpdateTime().getTime());</span>

<span class="fc" id="L668">		_query_findNotificationsById.setString(1, source);</span>
<span class="fc" id="L669">		_query_findNotificationsById.setString(2, type);</span>
<span class="fc" id="L670">		_query_findNotificationsById.setString(3, code);</span>
<span class="fc" id="L671">		_query_findNotificationsById.setDate(4, update);</span>

<span class="fc" id="L673">		return getNotifications(_query_findNotificationsById);</span>
	}

	/**
	 * Search the index for notifications matching the sources, types, and
	 * codes.
	 *
	 * Only one notification for each unique ProductId
	 * (source+type+code+updateTime) should be returned. If sources, types,
	 * and/or codes are null, that parameter should be considered a wildcard. If
	 * sources, types, and codes are all null, a notification for each unique
	 * ProductId in the index should be returned.
	 *
	 * @param source
	 *            sources to include, or all if null.
	 * @param type
	 *            types to include, or all if null.
	 * @param code
	 *            codes to include, or all if null.
	 * @return a list of matching notifications.
	 * @throws Exception
	 *             if an error occurs while searching the index.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized List&lt;Notification&gt; findNotifications(String source,
			String type, String code) throws Exception {
		// verify connection
<span class="fc" id="L700">		this.verifyConnection();</span>

<span class="fc bfc" id="L702" title="All 2 branches covered.">		source = (source == null) ? &quot;%&quot; : source.toUpperCase();</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">		type = (type == null) ? &quot;%&quot; : type.toUpperCase();</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">		code = (code == null) ? &quot;%&quot; : code.toUpperCase();</span>

<span class="fc" id="L706">		_query_findNotificationsByData.setString(1, source);</span>
<span class="fc" id="L707">		_query_findNotificationsByData.setString(2, type);</span>
<span class="fc" id="L708">		_query_findNotificationsByData.setString(3, code);</span>

<span class="fc" id="L710">		return getNotifications(_query_findNotificationsByData);</span>
	}

	/**
	 * Search the index for notifications matching the sources, types, and
	 * codes.
	 *
	 * Only one notification for each unique ProductId
	 * (source+type+code+updateTime) should be returned. If sources, types,
	 * and/or codes are null, that parameter should be considered a wildcard. If
	 * sources, types, and codes are all null, a notification for each unique
	 * ProductId in the index should be returned.
	 *
	 * This implementation require synchronization to prevent SQLExceptions
	 * caused by concurrent access. SQLite locks the database whenever there is
	 * an open ResultSet resource. So even read queries can end up causing SQL
	 * concurrent access problems.
	 *
	 * @param sources
	 *            sources to include, or all if null.
	 * @param types
	 *            types to include, or all if null.
	 * @param codes
	 *            codes to include, or all if null.
	 * @return a list of matching notifications.
	 * @throws Exception
	 *             if an error occurs while searching the index.
	 */
	public synchronized List&lt;Notification&gt; findNotifications(
			List&lt;String&gt; sources, List&lt;String&gt; types, List&lt;String&gt; codes)
			throws Exception {
		// verify connection
<span class="fc" id="L742">		this.verifyConnection();</span>

<span class="fc" id="L744">		List&lt;Notification&gt; n = null;</span>

<span class="fc" id="L746">		Connection conn = getConnection();</span>
		try {
			// begin a transaction
<span class="fc" id="L749">			conn.setAutoCommit(false);</span>

			// Create a temporary lookup table
<span class="fc" id="L752">			_dml_createTmpTable.executeUpdate();</span>

			// Populate the temporary lookup table with our given lists
<span class="fc bfc" id="L755" title="All 2 branches covered.">			if (sources != null) {</span>
				// Not null, insert values
<span class="fc" id="L757">				Iterator&lt;String&gt; iter = sources.iterator();</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">				while (iter.hasNext()) {</span>
<span class="fc" id="L759">					_dml_addTmpSource.setString(1, iter.next());</span>
<span class="fc" id="L760">					_dml_addTmpSource.addBatch();</span>
				}
<span class="fc" id="L762">				_dml_addTmpSource.executeBatch();</span>
			}

<span class="fc bfc" id="L765" title="All 2 branches covered.">			if (types != null) {</span>
				// Not null, insert values
<span class="fc" id="L767">				Iterator&lt;String&gt; iter = types.iterator();</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">				while (iter.hasNext()) {</span>
<span class="fc" id="L769">					_dml_addTmpType.setString(1, iter.next());</span>
<span class="fc" id="L770">					_dml_addTmpType.addBatch();</span>
				}
<span class="fc" id="L772">				_dml_addTmpType.executeBatch();</span>
			}

<span class="fc bfc" id="L775" title="All 2 branches covered.">			if (codes != null) {</span>
				// Not null, insert values
<span class="fc" id="L777">				Iterator&lt;String&gt; iter = codes.iterator();</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">				while (iter.hasNext()) {</span>
<span class="fc" id="L779">					_dml_addTmpCode.setString(1, iter.next());</span>
<span class="fc" id="L780">					_dml_addTmpCode.addBatch();</span>
				}
<span class="fc" id="L782">				_dml_addTmpCode.executeBatch();</span>
			}

			// is this a problem? reading with uncommitted writes?
<span class="fc" id="L786">			PreparedStatement ps = getCorrectStatement(sources, types, codes);</span>
<span class="fc" id="L787">			n = getNotifications(ps);</span>
		} finally {
<span class="fc" id="L789">			conn.rollback();</span>
			// todo: this looks funky, but it's re-enabling autoCommit, which is
			// needed for selects to not block other transactions
<span class="fc" id="L792">			conn.setAutoCommit(true);</span>
		}

<span class="fc" id="L795">		return n;</span>
	}

	/**
	 * Search the index for expired notifications.
	 *
	 * All expired notifications, even if duplicate, should be returned.
	 *
	 * @return a list of expired notifications.
	 * @throws Exception
	 *             if an error occurs while searching the index.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized List&lt;Notification&gt; findExpiredNotifications()
			throws Exception {
		// verify connection
<span class="fc" id="L811">		this.verifyConnection();</span>

		// Create a new calendar object set to current date/time
<span class="fc" id="L814">		java.sql.Date curDate = new java.sql.Date((new Date()).getTime());</span>

		// Bind the expiration date parameter and run the query
<span class="fc" id="L817">		_query_findExpiredNotifications.setDate(1, curDate);</span>

<span class="fc" id="L819">		return getNotifications(_query_findExpiredNotifications);</span>
	}

	/**
	 * Executes a prepared statement and parses the result set into a list of
	 * notifications. The prepared statement can have any set of criteria and
	 * all required parameters should be bound before calling this method. The
	 * result set of the prepared statement must include at least: -
	 * PRODUCT_SOURCE_COLUMN&lt;br&gt;
	 * - PRODUCT_TYPE_COLUMN&lt;br&gt;
	 * - PRODUCT_CODE_COLUMN&lt;br&gt;
	 * - PRODUCT_UPDATE_COLUMN&lt;br&gt;
	 * - EXPIRATION_DATE_COLUMN&lt;br&gt;
	 * - TRACKER_URL_COLUMN&lt;br&gt;
	 * - PRODUCT_URL_COLUMN&lt;br&gt;
	 *
	 * @param ps
	 *            The prepared statement to execute.
	 * @return A list of notifications returned by executing the statement.
	 * @throws Exception
	 *             If a &lt;code&gt;SQLException&lt;/code&gt; occurs.
	 */
	protected synchronized List&lt;Notification&gt; getNotifications(PreparedStatement ps)
			throws Exception {
<span class="fc" id="L843">		List&lt;Notification&gt; n = new ArrayList&lt;Notification&gt;();</span>
<span class="fc" id="L844">		ResultSet rs = null;</span>

		try {
<span class="fc" id="L847">			rs = ps.executeQuery();</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L849">				n.add(parseNotification(rs.getString(PRODUCT_SOURCE_COLUMN),</span>
<span class="fc" id="L850">						rs.getString(PRODUCT_TYPE_COLUMN),</span>
<span class="fc" id="L851">						rs.getString(PRODUCT_CODE_COLUMN),</span>
<span class="fc" id="L852">						rs.getDate(PRODUCT_UPDATE_COLUMN),</span>
<span class="fc" id="L853">						rs.getDate(EXPIRATION_DATE_COLUMN),</span>
<span class="fc" id="L854">						rs.getString(TRACKER_URL_COLUMN),</span>
<span class="fc" id="L855">						rs.getString(PRODUCT_URL_COLUMN)));</span>
			}
		} finally {
			try {
<span class="fc" id="L859">				rs.close();</span>
<span class="nc" id="L860">			} catch (Exception e) {</span>
				//ignore
<span class="fc" id="L862">			}</span>
		}

<span class="fc" id="L865">		return n;</span>
	}

	/**
	 * Creates and returns a &lt;code&gt;Notification&lt;/code&gt; based on the provided
	 * data. If the &lt;code&gt;download&lt;/code&gt; string references a valid URL, then a
	 * &lt;code&gt;URLNotification&lt;/code&gt; is created, otherwise a
	 * &lt;code&gt;DefaultNotification&lt;/code&gt; is created.
	 *
	 * @param source
	 *            The product source string.
	 * @param type
	 *            The product type string.
	 * @param code
	 *            The product code string.
	 * @param update
	 *            The latest update date/time for the product.
	 * @param expires
	 *            The date/time when this notification expires.
	 * @param tracker
	 *            A reference to a URL where information about this product is
	 *            posted.
	 * @param download
	 *            A reference to a URL where one can download this product, or
	 *            &lt;code&gt;null&lt;/code&gt; if this is not a
	 *            &lt;code&gt;URLNotification&lt;/code&gt;.
	 *
	 * @return The generated notification, or &lt;code&gt;null&lt;/code&gt; if one could not
	 *         be created (but an exception did not occur).
	 *
	 * @throws Exception
	 *             If the &lt;code&gt;tracker&lt;/code&gt; string cannot be successfully
	 *             parsed into a valid URL.
	 */
	protected Notification parseNotification(String source, String type,
			String code, java.sql.Date update, java.sql.Date expires,
			String tracker, String download) throws Exception {
<span class="fc" id="L902">		Notification n = null;</span>
<span class="fc" id="L903">		ProductId productId = new ProductId(source, type, code, update);</span>
		try {
<span class="fc" id="L905">			n = new URLNotification(productId, expires, new URL(tracker),</span>
					new URL(download));
<span class="fc" id="L907">		} catch (MalformedURLException mux) {</span>
<span class="fc" id="L908">			n = new DefaultNotification(productId, expires, new URL(tracker));</span>
<span class="fc" id="L909">		}</span>
<span class="fc" id="L910">		return n;</span>
	}

	protected PreparedStatement getCorrectStatement(List&lt;String&gt; sources,
			List&lt;String&gt; types, List&lt;String&gt; codes) throws Exception {
<span class="fc bfc" id="L915" title="All 6 branches covered.">		if (sources != null &amp;&amp; types != null &amp;&amp; codes != null) {</span>
<span class="fc" id="L916">			return _query_searchBySourceTypeCode;</span>
<span class="pc bpc" id="L917" title="1 of 6 branches missed.">		} else if (sources != null &amp;&amp; types != null &amp;&amp; codes == null) {</span>
<span class="fc" id="L918">			return _query_searchBySourceType;</span>
<span class="pc bpc" id="L919" title="2 of 6 branches missed.">		} else if (sources != null &amp;&amp; types == null &amp;&amp; codes != null) {</span>
<span class="nc" id="L920">			return _query_searchBySourceCode;</span>
<span class="fc bfc" id="L921" title="All 6 branches covered.">		} else if (sources == null &amp;&amp; types != null &amp;&amp; codes != null) {</span>
<span class="fc" id="L922">			return _query_searchByTypeCode;</span>
<span class="pc bpc" id="L923" title="2 of 6 branches missed.">		} else if (sources != null &amp;&amp; types == null &amp;&amp; codes == null) {</span>
<span class="fc" id="L924">			return _query_searchBySource;</span>
<span class="pc bpc" id="L925" title="2 of 6 branches missed.">		} else if (sources == null &amp;&amp; types != null &amp;&amp; codes == null) {</span>
<span class="fc" id="L926">			return _query_searchByType;</span>
<span class="pc bpc" id="L927" title="2 of 6 branches missed.">		} else if (sources == null &amp;&amp; types == null &amp;&amp; codes != null) {</span>
<span class="fc" id="L928">			return _query_searchByCode;</span>
<span class="pc bpc" id="L929" title="3 of 6 branches missed.">		} else if (sources == null &amp;&amp; types == null &amp;&amp; codes == null) {</span>
<span class="fc" id="L930">			return _query_getAllNotifications;</span>
		}

<span class="nc" id="L933">		return null;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>