<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileProductStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.distribution</a> &gt; <span class="el_source">FileProductStorage.java</span></div><h1>FileProductStorage.java</h1><pre class="source lang-java linenums">/*
 * FileProductStorage
 */
package gov.usgs.earthquake.distribution;

import gov.usgs.earthquake.product.ByteContent;
import gov.usgs.earthquake.product.Content;
import gov.usgs.earthquake.product.Product;
import gov.usgs.earthquake.product.ProductId;
import gov.usgs.earthquake.product.io.DirectoryProductHandler;
import gov.usgs.earthquake.product.io.DirectoryProductSource;
import gov.usgs.earthquake.product.io.FilterProductHandler;
import gov.usgs.earthquake.product.io.ObjectProductHandler;
import gov.usgs.earthquake.product.io.ObjectProductSource;
import gov.usgs.earthquake.product.io.ProductHandler;
import gov.usgs.earthquake.product.io.ProductSource;
import gov.usgs.util.Config;
import gov.usgs.util.DefaultConfigurable;
import gov.usgs.util.FileUtils;
import gov.usgs.util.ObjectLock;
import gov.usgs.util.StreamUtils;
import gov.usgs.util.StringUtils;

import java.io.File;
import java.io.InputStream;
import java.net.URL;
import java.security.MessageDigest;
import java.security.PublicKey;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Store products in the file system.
 * 
 * This implementation of ProductStorage extracts products into directories.
 * 
 * The FileProductStorage implements the Configurable interface and can use the
 * following configuration parameters:
 * 
 * &lt;dl&gt;
 * &lt;dt&gt;directory&lt;/dt&gt;
 * &lt;dd&gt;(Optional, default = storage) The base directory where products are
 * stored. Each product is stored in a separate directory within this directory.
 * &lt;/dd&gt;
 * 
 * &lt;dt&gt;verifySignatures&lt;/dt&gt;
 * &lt;dd&gt;(Optional, default = off) Whether or not to verify signatures:
 * &lt;dl&gt;
 * &lt;dt&gt;off&lt;/dt&gt;
 * &lt;dd&gt;no verification&lt;/dd&gt;
 * 
 * &lt;dt&gt;test&lt;/dt&gt;
 * &lt;dd&gt;test but accept invalid signatures&lt;/dd&gt;
 * 
 * &lt;dt&gt;anything else&lt;/dt&gt;
 * &lt;dd&gt;reject invalid signatures.&lt;/dd&gt;
 * &lt;/dl&gt;
 * &lt;/dd&gt;
 * 
 * &lt;dt&gt;keychain&lt;/dt&gt;
 * &lt;dd&gt;(Optional) List of key section names to load for signature verification.&lt;/dd&gt;
 * &lt;/dl&gt;
 * 
 * An attempt is made to make storage operations atomic by using read and write
 * locks. While a write operation (store or remove) is in progress, read
 * operations will block. It is possible for a remove operation to occur between
 * the time getProduct() returns and the time when product contents are actually
 * loaded from a file. Users who are concerned about this should use the
 * getInMemoryProduct() method, which holds a read lock until all product files
 * are read.
 * 
 * To override the directory structure or format, override one or more of the
 * following methods:
 * 
 * &lt;pre&gt;
 * String getProductPath(ProductId)
 * ProductSource getProductSourceFormat(File)
 * ProductOutput getProductHandlerFormat(File)
 * &lt;/pre&gt;
 */
public class FileProductStorage extends DefaultConfigurable implements
		ProductStorage {

	/** Logging object. */
<span class="fc" id="L92">	private static final Logger LOGGER = Logger</span>
<span class="fc" id="L93">			.getLogger(FileProductStorage.class.getName());</span>

	/** Property for configured listeners */
	public static final String STORAGE_LISTENER_PROPERTY = &quot;listeners&quot;;

	/** Storage path property name used by Configurable interface. */
	public static final String DIRECTORY_PROPERTY_NAME = &quot;directory&quot;;
	/** Default storage path if none is provided. */
	public static final String DEFAULT_DIRECTORY = &quot;storage&quot;;

	/** Property for whether or not to verify signatures. */
	public static final String VERIFY_SIGNATURES_PROPERTY_NAME = &quot;verifySignatures&quot;;
	/** Don't verify signatures (Default). */
	public static final String DEFAULT_VERIFY_SIGNATURE = &quot;off&quot;;
	/** Test signatures, but don't reject invalid. */
	public static final String TEST_VERIFY_SIGNATURE = &quot;test&quot;;

	/** Property for whether or not to hash file paths. */
	public static final String USE_HASH_PATHS_PROPERTY = &quot;useHashes&quot;;
	/** Do not use hashes (Default). */
	public static final boolean USE_HASH_PATHS_DEFAULT = false;

	/** Property for a list of keys. */
	public static final String KEYCHAIN_PROPERTY_NAME = &quot;keychain&quot;;

	/** Property for a file of keys. */
	public static final String KEYCHAIN_FILE_PROPERTY_NAME = &quot;keychainFile&quot;;

	/** Property for legacyStorages. */
	public static final String LEGACY_STORAGES_PROPERTY = &quot;legacyStorages&quot;;

	/** Base directory for product storage. */
	private File baseDirectory;

<span class="fc" id="L127">	private boolean useHashes = USE_HASH_PATHS_DEFAULT;</span>

	/** Locks used to make storage operations atomic. */
<span class="fc" id="L130">	private ObjectLock&lt;ProductId&gt; storageLocks = new ObjectLock&lt;ProductId&gt;();</span>

	/**
	 * @return the storageLocks
	 */
	public ObjectLock&lt;ProductId&gt; getStorageLocks() {
<span class="fc" id="L136">		return storageLocks;</span>
	}

	/** Whether or not to reject invalid signatures. */
<span class="fc" id="L140">	private boolean rejectInvalidSignatures = false;</span>

	/** If not rejecting invalid signatures, test them anyways. */
<span class="fc" id="L143">	private boolean testSignatures = false;</span>

	/** Keys used when testing signatures. */
	private ProductKeyChain keychain;

<span class="fc" id="L148">	private Map&lt;StorageListener, ExecutorService&gt; listeners = new HashMap&lt;StorageListener, ExecutorService&gt;();</span>

	/**
	 * A list of product storages used only for retrieving products, never for
	 * storing. Assists with migration between formats and other settings.
	 */
<span class="fc" id="L154">	private final ArrayList&lt;ProductStorage&gt; legacyStorages = new ArrayList&lt;ProductStorage&gt;();</span>

	/**
	 * Create this digest once, and clone it later. Only used if
	 * &lt;code&gt;useHashed&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.
	 */
	private static final MessageDigest SHA_DIGEST;
	static {
<span class="fc" id="L162">		MessageDigest digest = null;</span>
		try {
<span class="fc" id="L164">			digest = MessageDigest.getInstance(&quot;SHA&quot;);</span>
<span class="nc" id="L165">		} catch (Exception e) {</span>
<span class="nc" id="L166">			LOGGER.warning(&quot;Unable to create SHA Digest for HashFileProductStorage&quot;);</span>
<span class="nc" id="L167">			digest = null;</span>
<span class="fc" id="L168">		}</span>
<span class="fc" id="L169">		SHA_DIGEST = digest;</span>
<span class="fc" id="L170">	}</span>

	/**
	 * This is chosen because 16^3 = 4096 &amp;lt; 32000, which is the ext3
	 * subdirectory limit.
	 */
	public static final int DIRECTORY_NAME_LENGTH = 3;

	/**
	 * Create a new FileProductStorage using the default storage path.
	 */
	public FileProductStorage() {
<span class="fc" id="L182">		this(new File(DEFAULT_DIRECTORY));</span>
<span class="fc" id="L183">	}</span>

	/**
	 * Create a new FileProductStorage.
	 * 
	 * @param baseDirectory
	 *            the base directory for all products being stored.
	 */
<span class="fc" id="L191">	public FileProductStorage(final File baseDirectory) {</span>
<span class="fc" id="L192">		this.baseDirectory = baseDirectory;</span>
<span class="fc" id="L193">	}</span>

	/**
	 * Configure this object.
	 * 
	 * Expects a key named &quot;directory&quot;.
	 */
	public void configure(Config config) throws Exception {
<span class="fc" id="L201">		String directory = config.getProperty(DIRECTORY_PROPERTY_NAME,</span>
				DEFAULT_DIRECTORY);
<span class="fc" id="L203">		baseDirectory = new File(directory);</span>
<span class="fc" id="L204">		LOGGER.config(&quot;[&quot; + getName() + &quot;] using storage directory &quot;</span>
<span class="fc" id="L205">				+ baseDirectory.getCanonicalPath());</span>

<span class="fc" id="L207">		String verifySignatures = config</span>
<span class="fc" id="L208">				.getProperty(VERIFY_SIGNATURES_PROPERTY_NAME);</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">		if (verifySignatures != null) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">			if (verifySignatures.equals(TEST_VERIFY_SIGNATURE)) {</span>
<span class="nc" id="L211">				testSignatures = true;</span>
<span class="nc" id="L212">				LOGGER.config(&quot;[&quot; + getName() + &quot;] test message signatures&quot;);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">			} else if (!verifySignatures.equals(DEFAULT_VERIFY_SIGNATURE)) {</span>
<span class="nc" id="L214">				rejectInvalidSignatures = true;</span>
<span class="nc" id="L215">				LOGGER.config(&quot;[&quot; + getName() + &quot;] reject invalid signatures&quot;);</span>
			}

<span class="nc" id="L218">			String keyNames = config.getProperty(KEYCHAIN_PROPERTY_NAME);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">			if (keyNames != null) {</span>
<span class="nc" id="L220">				LOGGER.config(&quot;[&quot; + getName() + &quot;] using product keys &quot;</span>
						+ keyNames);
<span class="nc" id="L222">				keychain = new ProductKeyChain(keyNames, Config.getConfig());</span>
			} else {
<span class="nc" id="L224">				String keychainFileName = config</span>
<span class="nc" id="L225">						.getProperty(KEYCHAIN_FILE_PROPERTY_NAME);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">				if (keychainFileName != null) {</span>
<span class="nc" id="L227">					Config keychainConfig = new Config();</span>
<span class="nc" id="L228">					InputStream keychainFileInputStream = StreamUtils.getInputStream(</span>
							new File(keychainFileName));
					try {
<span class="nc" id="L231">						keychainConfig.load(keychainFileInputStream);</span>
					} finally {
<span class="nc" id="L233">						StreamUtils.closeStream(keychainFileInputStream);</span>
					}
<span class="nc" id="L235">					keyNames = keychainConfig</span>
<span class="nc" id="L236">							.getProperty(KEYCHAIN_PROPERTY_NAME);</span>
<span class="nc" id="L237">					keychain = new ProductKeyChain(keyNames, keychainConfig);</span>
<span class="nc" id="L238">				} else {</span>
<span class="nc" id="L239">					LOGGER.warning(&quot;[&quot; + getName()</span>
							+ &quot;] no product keys configured&quot;);
<span class="nc" id="L241">					keychain = new ProductKeyChain();</span>
				}
			}
		}

		// Set up our configured listeners
<span class="fc" id="L247">		Iterator&lt;String&gt; listenerIter = StringUtils.split(</span>
<span class="fc" id="L248">				config.getProperty(STORAGE_LISTENER_PROPERTY), &quot;,&quot;).iterator();</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">		while (listenerIter.hasNext()) {</span>
<span class="fc" id="L250">			String listenerName = listenerIter.next();</span>
			try {
<span class="fc" id="L252">				StorageListener listener = (StorageListener) Config.getConfig()</span>
<span class="fc" id="L253">						.getObject(listenerName);</span>
<span class="fc" id="L254">				addStorageListener(listener);</span>
<span class="nc" id="L255">			} catch (Exception ccx) {</span>
<span class="nc" id="L256">				throw new ConfigurationException(&quot;[&quot; + getName()</span>
						+ &quot;] listener \&quot;&quot; + listenerName
<span class="nc" id="L258">						+ &quot;\&quot; was not properly configured. &quot; + ccx.getMessage());</span>
<span class="fc" id="L259">			}</span>
<span class="fc" id="L260">		}</span>

		// load legacy storages
<span class="fc" id="L263">		Iterator&lt;String&gt; legacyIter = StringUtils.split(</span>
<span class="fc" id="L264">				config.getProperty(LEGACY_STORAGES_PROPERTY), &quot;,&quot;).iterator();</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">		while (legacyIter.hasNext()) {</span>
<span class="nc" id="L266">			String legacyName = legacyIter.next();</span>
			try {
				ProductStorage legacyStorage = (ProductStorage) Config
<span class="nc" id="L269">						.getConfig().getObject(legacyName);</span>
<span class="nc" id="L270">				legacyStorages.add(legacyStorage);</span>
<span class="nc" id="L271">			} catch (Exception e) {</span>
<span class="nc" id="L272">				throw new ConfigurationException(&quot;[&quot; + getName()</span>
						+ &quot;] legacy storage '&quot; + legacyName
<span class="nc" id="L274">						+ &quot;' not properly configured. &quot; + e.getMessage());</span>
<span class="nc" id="L275">			}</span>
<span class="nc" id="L276">		}</span>
<span class="fc" id="L277">	}</span>

	@Override
	public synchronized void notifyListeners(final StorageEvent event) {
<span class="fc" id="L281">		Iterator&lt;StorageListener&gt; listenerIter = listeners.keySet().iterator();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">		while (listenerIter.hasNext()) {</span>
<span class="fc" id="L283">			final StorageListener listener = listenerIter.next();</span>
<span class="fc" id="L284">			LOGGER.finer(&quot;[&quot; + getName() + &quot;] listener :: &quot;</span>
<span class="fc" id="L285">					+ listener.getClass().getCanonicalName());</span>
<span class="fc" id="L286">			final ExecutorService service = listeners.get(listener);</span>

<span class="fc" id="L288">			service.submit(new Runnable() {</span>

				public void run() {
<span class="fc" id="L291">					listener.onStorageEvent(event);</span>
<span class="fc" id="L292">				}</span>
			});
<span class="fc" id="L294">		}</span>
<span class="fc" id="L295">	}</span>

	@Override
	public void addStorageListener(final StorageListener listener) {
<span class="fc" id="L299">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] adding listener :: &quot;</span>
<span class="fc" id="L300">				+ listener.getClass().getCanonicalName());</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">		if (!listeners.containsKey(listener)) {</span>
<span class="fc" id="L302">			ExecutorService service = Executors.newSingleThreadExecutor();</span>
<span class="fc" id="L303">			listeners.put(listener, service);</span>
		}
<span class="fc" id="L305">	}</span>

	@Override
	public void removeStorageListener(final StorageListener listener) {
<span class="fc" id="L309">		ExecutorService service = listeners.remove(listener);</span>

<span class="pc bpc" id="L311" title="1 of 2 branches missed.">		if (service != null) {</span>
<span class="fc" id="L312">			service.shutdown();</span>
		}
<span class="fc" id="L314">	}</span>

	/**
	 * A method for subclasses to override the storage path.
	 * 
	 * The returned path is appended to the base directory when storing and
	 * retrieving products.
	 * 
	 * @param id
	 *            the product id to convert.
	 * @return the directory used to store id.
	 */
	public String getProductPath(final ProductId id) {

<span class="pc bpc" id="L328" title="1 of 2 branches missed.">		if (useHashes) {</span>
<span class="nc" id="L329">			return getHashedProductPath(id);</span>
		} else {
<span class="fc" id="L331">			return getNormalProductPath(id);</span>
		}
	}

	protected String getHashedProductPath(final ProductId id) {
		try {
			MessageDigest digest;
<span class="nc" id="L338">			synchronized (SHA_DIGEST) {</span>
<span class="nc" id="L339">				digest = ((MessageDigest) SHA_DIGEST.clone());</span>
<span class="nc" id="L340">			}</span>

<span class="nc" id="L342">			String hexDigest = toHexString(digest.digest(id.toString()</span>
<span class="nc" id="L343">					.getBytes()));</span>

<span class="nc" id="L345">			StringBuffer buf = new StringBuffer();</span>
			// start with product type, to give idea of available products and
			// disk usage when looking at filesystem
<span class="nc" id="L348">			buf.append(id.getType());</span>

			// sub directories based on hash
<span class="nc" id="L351">			int length = hexDigest.length();</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">			for (int i = 0; i &lt; length; i += DIRECTORY_NAME_LENGTH) {</span>
				String part;
<span class="nc bnc" id="L354" title="All 2 branches missed.">				if (i + DIRECTORY_NAME_LENGTH &lt; length) {</span>
<span class="nc" id="L355">					part = hexDigest.substring(i, i + DIRECTORY_NAME_LENGTH);</span>
				} else {
<span class="nc" id="L357">					part = hexDigest.substring(i);</span>
				}
<span class="nc" id="L359">				buf.append(File.separator);</span>
<span class="nc" id="L360">				buf.append(part);</span>
			}

<span class="nc" id="L363">			return buf.toString();</span>
<span class="nc" id="L364">		} catch (CloneNotSupportedException e) {</span>
			// fall back to parent class
<span class="nc" id="L366">			return getNormalProductPath(id);</span>
		}
	}

	/**
	 * Convert an array of bytes into a hex string. The string will always be
	 * twice as long as the input byte array, because bytes &lt; 0x10 are zero
	 * padded.
	 * 
	 * @param bytes
	 *            byte array to convert to hex.
	 * @return hex string equivalent of input byte array.
	 */
	private String toHexString(final byte[] bytes) {
<span class="nc" id="L380">		StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L381">		int length = bytes.length;</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">		for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L383">			String hex = Integer.toHexString(0xFF &amp; bytes[i]);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">			if (hex.length() == 1) {</span>
<span class="nc" id="L385">				buf.append('0');</span>
			}
<span class="nc" id="L387">			buf.append(hex);</span>
		}
<span class="nc" id="L389">		return buf.toString();</span>
	}

	public String getNormalProductPath(final ProductId id) {
<span class="fc" id="L393">		StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L394">		buf.append(id.getType());</span>
<span class="fc" id="L395">		buf.append(File.separator);</span>
<span class="fc" id="L396">		buf.append(id.getCode());</span>
<span class="fc" id="L397">		buf.append(File.separator);</span>
<span class="fc" id="L398">		buf.append(id.getSource());</span>
<span class="fc" id="L399">		buf.append(File.separator);</span>
<span class="fc" id="L400">		buf.append(id.getUpdateTime().getTime());</span>
<span class="fc" id="L401">		return buf.toString();</span>
	}

	/**
	 * A method for subclasses to override the storage format.
	 * 
	 * When overriding this method, the method getProductSourceFormat should
	 * also be overridden.
	 * 
	 * @param file
	 *            a file that should be converted into a ProductHandler.
	 * @return the ProductHandler.
	 */
	protected ProductHandler getProductHandlerFormat(final File file)
			throws Exception {
<span class="fc" id="L416">		return new DirectoryProductHandler(file);</span>
	}

	/**
	 * A method for subclasses to override the storage format.
	 * 
	 * When overriding this method, the method getProductHandlerFormat should
	 * also be overridden.
	 * 
	 * @param file
	 *            a file that should be converted into a ProductSource.
	 * @return the ProductSource.
	 */
	protected ProductSource getProductSourceFormat(final File file)
			throws Exception {
<span class="fc" id="L431">		return new DirectoryProductSource(file);</span>
	}

	/**
	 * Get the file or directory used to store a specific product.
	 * 
	 * @param id
	 *            which product.
	 * @return a file or directory where the product would be stored.
	 */
	public File getProductFile(final ProductId id) {
<span class="fc" id="L442">		String path = getProductPath(id);</span>
		// remove any leading slash so path will always be within baseDirectory.
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">		if (path.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L445">			path = path.substring(1);</span>
		}
<span class="fc" id="L447">		return new File(baseDirectory, path);</span>
	}

	/**
	 * Get a product from storage.
	 * 
	 * Calls the getProductSource method, and uses ObjectProductHandler to
	 * convert the ProductSource into a Product.
	 * 
	 * @param id
	 *            the product to retrieve.
	 * @return the product, or null if not in this storage.
	 */
	public Product getProduct(ProductId id) throws Exception {
<span class="fc" id="L461">		ProductSource source = getProductSource(id);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">		if (source == null) {</span>
<span class="fc" id="L463">			return null;</span>
		} else {
<span class="fc" id="L465">			return ObjectProductHandler.getProduct(source);</span>
		}
	}

	/**
	 * Get a product from storage, loading all file contents into memory.
	 * 
	 * This method may cause memory problems if product contents are large.
	 * 
	 * @param id
	 *            the product to retrieve.
	 * @return the loaded product.
	 * @throws Exception
	 */
	public Product getInMemoryProduct(ProductId id) throws Exception {
<span class="nc" id="L480">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquiring read lock for product id=&quot;</span>
<span class="nc" id="L481">				+ id.toString());</span>
<span class="nc" id="L482">		storageLocks.acquireReadLock(id);</span>
<span class="nc" id="L483">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquired read lock for product id=&quot;</span>
<span class="nc" id="L484">				+ id.toString());</span>
		try {
			// load product
<span class="nc" id="L487">			Product product = getProduct(id);</span>
			// convert all contents to ByteContent
<span class="nc" id="L489">			Map&lt;String, Content&gt; contents = product.getContents();</span>
<span class="nc" id="L490">			Iterator&lt;String&gt; iter = contents.keySet().iterator();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">			while (iter.hasNext()) {</span>
<span class="nc" id="L492">				String path = iter.next();</span>
<span class="nc" id="L493">				contents.put(path, new ByteContent(contents.get(path)));</span>
<span class="nc" id="L494">			}</span>
			// product content is all in memory
<span class="nc" id="L496">			return product;</span>
		} finally {
<span class="nc" id="L498">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="nc" id="L499">					+ &quot;] releasing read lock for product id=&quot; + id.toString());</span>
<span class="nc" id="L500">			storageLocks.releaseReadLock(id);</span>
<span class="nc" id="L501">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="nc" id="L502">					+ &quot;] released write lock for product id=&quot; + id.toString());</span>
		}
	}

	/**
	 * Get a ProductSource from storage.
	 * 
	 * @param id
	 *            the product to retrieve.
	 * @return a ProductSource for the product, or null if not in this storage.
	 */
	public ProductSource getProductSource(ProductId id) throws Exception {
<span class="fc" id="L514">		ProductSource productSource = null;</span>

<span class="fc" id="L516">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquiring read lock for product id=&quot;</span>
<span class="fc" id="L517">				+ id.toString());</span>
		// acquire lock in case storage operation in progress
<span class="fc" id="L519">		storageLocks.acquireReadLock(id);</span>
<span class="fc" id="L520">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquired read lock for product id=&quot;</span>
<span class="fc" id="L521">				+ id.toString());</span>
		try {
<span class="fc" id="L523">			File productFile = getProductFile(id);</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">			if (productFile.exists()) {</span>
<span class="fc" id="L525">				productSource = getProductSourceFormat(productFile);</span>
			}
<span class="fc bfc" id="L527" title="All 2 branches covered.">			if (productSource == null) {</span>
<span class="fc" id="L528">				Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">				while (legacyIter.hasNext()) {</span>
<span class="nc" id="L530">					ProductStorage next = legacyIter.next();</span>
					try {
<span class="nc" id="L532">						productSource = next.getProductSource(id);</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">						if (productSource != null) {</span>
<span class="nc" id="L534">							break;</span>
						}
<span class="nc" id="L536">					} catch (Exception e) {</span>
<span class="nc" id="L537">						LOGGER.log(Level.FINE, &quot;[&quot; + getName() + &quot;] &quot; +</span>
								&quot;legacy storage getProductSource exception &quot;, e);
<span class="nc" id="L539">					}</span>
<span class="nc" id="L540">				}</span>
			}
		} finally {
			// release the lock no matter what
<span class="fc" id="L544">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L545">					+ &quot;] releasing read lock for product id=&quot; + id.toString());</span>
<span class="fc" id="L546">			storageLocks.releaseReadLock(id);</span>
<span class="fc" id="L547">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L548">					+ &quot;] released read lock for product id=&quot; + id.toString());</span>
		}

<span class="fc" id="L551">		return productSource;</span>
	}

	/**
	 * Check whether a product exists in storage.
	 * 
	 * @param id
	 *            the product to check.
	 * @return true if the product exists, false otherwise.
	 */
	public boolean hasProduct(ProductId id) throws Exception {
<span class="fc" id="L562">		boolean hasProduct = false;</span>

<span class="fc" id="L564">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquiring read lock for product id=&quot;</span>
<span class="fc" id="L565">				+ id.toString());</span>
		// acquire lock in case storage operation in progress
<span class="fc" id="L567">		storageLocks.acquireReadLock(id);</span>
<span class="fc" id="L568">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquired read lock for product id=&quot;</span>
<span class="fc" id="L569">				+ id.toString());</span>
		try {
<span class="fc" id="L571">			File productDirectory = getProductFile(id);</span>
<span class="fc" id="L572">			hasProduct = productDirectory.exists();</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">			if (hasProduct) {</span>
				// be a little more detailed...
<span class="fc" id="L575">				ProductSource source = getProductSource(id);</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">				if (source == null) {</span>
<span class="nc" id="L577">					hasProduct = false;</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">				} else if (source instanceof DirectoryProductSource) {</span>
					// not sure how we would get here
					// FileNotFound exception appears in logs...
<span class="fc" id="L581">					hasProduct = (new File(productDirectory,</span>
							DirectoryProductHandler.PRODUCT_XML_FILENAME)
<span class="fc" id="L583">							.exists());</span>
				}
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">				if (source != null) {</span>
<span class="fc" id="L586">					source.close();</span>
				}
			}

<span class="fc bfc" id="L590" title="All 2 branches covered.">			if (!hasProduct) {</span>
				// primary storage doesn't have product, check legacy storages
<span class="fc" id="L592">				Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">				while (legacyIter.hasNext()) {</span>
<span class="fc" id="L594">					ProductStorage next = legacyIter.next();</span>
					try {
<span class="fc bfc" id="L596" title="All 2 branches covered.">						if (next.hasProduct(id)) {</span>
<span class="fc" id="L597">							return true;</span>
						}
<span class="nc" id="L599">					} catch (Exception e) {</span>
<span class="nc" id="L600">						LOGGER.log(Level.FINE, &quot;[&quot; + getName()</span>
								+ &quot;] legacy storage hasProduct exception &quot;, e);
<span class="fc" id="L602">					}</span>
<span class="fc" id="L603">				}</span>
			}
		} finally {
<span class="fc" id="L606">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L607">					+ &quot;] releasing read lock for product id=&quot; + id.toString());</span>
			// release lock no matter what
<span class="fc" id="L609">			storageLocks.releaseReadLock(id);</span>
<span class="fc" id="L610">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L611">					+ &quot;] released read lock for product id=&quot; + id.toString());</span>
		}

<span class="fc" id="L614">		return hasProduct;</span>
	}

	/**
	 * Remove a product from storage.
	 * 
	 * @param id
	 *            product to remove.
	 */
	public void removeProduct(ProductId id) throws Exception {
<span class="fc" id="L624">		String idString = id.toString();</span>
<span class="fc" id="L625">		LOGGER.finest(&quot;[&quot; + getName()</span>
				+ &quot;] acquiring write lock for product id=&quot; + idString);
		// acquire lock in case storage operation in progress
<span class="fc" id="L628">		storageLocks.acquireWriteLock(id);</span>
<span class="fc" id="L629">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquired write lock for product id=&quot;</span>
				+ idString);
		try {
<span class="fc" id="L632">			File productFile = getProductFile(id);</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">			if (productFile.exists()) {</span>
				// recursively delete the product directory
<span class="fc" id="L635">				FileUtils.deleteTree(productFile);</span>
				// remove any empty parent directories
<span class="fc" id="L637">				FileUtils.deleteEmptyParents(productFile, baseDirectory);</span>
<span class="fc" id="L638">				LOGGER.finer(&quot;[&quot; + getName() + &quot;] product removed, id=&quot; + idString);</span>
			}
<span class="fc" id="L640">			productFile = null;</span>
			// remove from any legacy storages
<span class="fc" id="L642">			Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">			while (legacyIter.hasNext()) {</span>
<span class="fc" id="L644">				ProductStorage next = legacyIter.next();</span>
				try {
<span class="fc" id="L646">					next.removeProduct(id);</span>
<span class="nc" id="L647">				} catch (Exception e) {</span>
<span class="nc" id="L648">					LOGGER.log(Level.FINE, &quot;[&quot; + getName()</span>
							+ &quot;] legacy storage remove exception &quot;, e);
<span class="fc" id="L650">				}</span>
<span class="fc" id="L651">			}</span>
		} finally {
<span class="fc" id="L653">			LOGGER.finest(&quot;[&quot; + getName()</span>
					+ &quot;] releasing write lock for product id=&quot; + idString);
			// release lock no matter what
<span class="fc" id="L656">			storageLocks.releaseWriteLock(id);</span>
<span class="fc" id="L657">			LOGGER.finest(&quot;[&quot; + getName()</span>
					+ &quot;] released write lock for product id=&quot; + idString);
		}

		// Notify listeners
<span class="fc" id="L662">		notifyListeners(new StorageEvent(this, id, StorageEvent.PRODUCT_REMOVED));</span>
<span class="fc" id="L663">	}</span>

	/**
	 * Store a product in storage.
	 * 
	 * Same as storeProductSource(new ObjectProductSource(product)).
	 * 
	 * @param product
	 *            the product to store.
	 * @return the id of the stored product.
	 */
	public ProductId storeProduct(Product product) throws Exception {
<span class="fc" id="L675">		return storeProductSource(new ObjectProductSource(product));</span>
	}

	/**
	 * Store a ProductSource to storage.
	 * 
	 * If any exceptions occur while storing a product (other than the product
	 * already existing in storage) the incompletely stored product is removed.
	 * 
	 * @param source
	 *            the ProductSource to store.
	 * @return the id of the stored product.
	 */
	public ProductId storeProductSource(ProductSource source) throws Exception {
<span class="fc" id="L689">		StorageProductOutput output = new StorageProductOutput();</span>
		// output acquires the storageLock during onBeginProduct, once the
		// product id is known.
		try {
<span class="fc" id="L693">			source.streamTo(output);</span>

<span class="fc" id="L695">			ProductId id = output.getProductId();</span>
<span class="fc" id="L696">			LOGGER.finer(&quot;[&quot; + getName() + &quot;] product stored id=&quot; + id</span>
<span class="fc" id="L697">					+ &quot;, status=&quot; + output.getStatus());</span>

<span class="fc bfc" id="L699" title="All 4 branches covered.">			if (testSignatures || rejectInvalidSignatures) {</span>
<span class="fc" id="L700">				Product product = getProduct(id);</span>

<span class="fc" id="L702">				boolean verified = false;</span>
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">				if (keychain != null) {</span>
<span class="fc" id="L704">					PublicKey[] candidateKeys = keychain.getProductKeys(id);</span>
<span class="fc" id="L705">					LOGGER.finer(&quot;[&quot; + getName()</span>
							+ &quot;] number of candidate keys=&quot;
							+ candidateKeys.length);
<span class="fc" id="L708">					verified = product.verifySignature(candidateKeys);</span>
<span class="fc" id="L709">				} else {</span>
<span class="nc" id="L710">					LOGGER.warning(&quot;[&quot; + getName()</span>
							+ &quot;] missing Signature Keychain&quot;);
				}

<span class="fc" id="L714">				LOGGER.fine(&quot;[&quot; + getName() + &quot;] signature verified=&quot;</span>
<span class="fc" id="L715">						+ verified + &quot;, id=&quot; + product.getId());</span>

<span class="pc bpc" id="L717" title="1 of 4 branches missed.">				if (!verified &amp;&amp; rejectInvalidSignatures) {</span>
<span class="fc" id="L718">					removeProduct(id);</span>
<span class="fc" id="L719">					throw new InvalidSignatureException(&quot;[&quot; + getName()</span>
							+ &quot;] bad signature for id=&quot; + id);
				}
			}
<span class="fc" id="L723">		} catch (Exception e) {</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">			if (!(e instanceof ProductAlreadyInStorageException)</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">					&amp;&amp; !(e.getCause() instanceof ProductAlreadyInStorageException)) {</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">				if (e instanceof InvalidSignatureException) {</span>
					// suppress stack trace for invalid signature
<span class="fc" id="L728">					LOGGER.warning(e.getMessage()</span>
							+ &quot;, removing incomplete product&quot;);
				} else {
<span class="fc" id="L731">					LOGGER.log(</span>
							Level.WARNING,
							&quot;[&quot;
<span class="fc" id="L734">									+ getName()</span>
									+ &quot;] exception while storing product, removing incomplete product&quot;,
							e);
				}
				try {
					// remove incompletely stored product.
<span class="fc" id="L740">					removeProduct(output.getProductId());</span>
<span class="nc" id="L741">				} catch (Exception e2) {</span>
					// ignore
<span class="nc" id="L743">					LOGGER.log(Level.WARNING, &quot;[&quot; + getName()</span>
							+ &quot;] exception while removing incomplete product&quot;,
							e2);
<span class="fc" id="L746">				}</span>
			}
<span class="fc" id="L748">			throw e;</span>
		} finally {
			// DO RELEASE THE WRITE LOCK HERE

			// This leads to thread sync problems in
			// SearchResponseXmlProductSource, because xml events were sent in
			// one thread, leading to acquisition of a write lock, while this
			// method was called in a separate thread and attempted to release
			// the write lock.

			// However, not releasing the lock here leads to other problems when
			// hubs are receiving products via multiple receivers.

<span class="fc" id="L761">			ProductId id = output.getProductId();</span>

<span class="pc bpc" id="L763" title="1 of 2 branches missed.">			if (id != null) {</span>
				// release the write lock
<span class="fc" id="L765">				LOGGER.finest(&quot;[&quot; + getName()</span>
						+ &quot;] releasing write lock for product id=&quot;
<span class="fc" id="L767">						+ id.toString());</span>
<span class="fc" id="L768">				storageLocks.releaseWriteLock(id);</span>
<span class="fc" id="L769">				LOGGER.finest(&quot;[&quot; + getName()</span>
						+ &quot;] released write lock for product id=&quot;
<span class="fc" id="L771">						+ id.toString());</span>
			}

			// close underlying handler
<span class="fc" id="L775">			output.close();</span>
<span class="fc" id="L776">			output.setProductOutput(null);</span>

<span class="fc" id="L778">			source.close();</span>
		}

<span class="fc" id="L781">		ProductId id = output.getProductId();</span>
		// Notify our storage listeners
<span class="fc" id="L783">		StorageEvent event = new StorageEvent(this, id,</span>
				StorageEvent.PRODUCT_STORED);
<span class="fc" id="L785">		notifyListeners(event);</span>

<span class="fc" id="L787">		return id;</span>
	}

	/**
	 * Used when storing products.
	 * 
	 * When onBeginProduct is called with the ProductId being stored, a
	 * DirectoryProductOutput is created which manages storage.
	 */
	private class StorageProductOutput extends FilterProductHandler {

		/** The stored product id. */
		private ProductId id;

		/** The stored product status. */
		private String status;

		/**
		 * Construct a new StorageProductOutput.
		 */
<span class="fc" id="L807">		public StorageProductOutput() {</span>
<span class="fc" id="L808">		}</span>

		/**
		 * @return the product id that was stored.
		 */
		public ProductId getProductId() {
<span class="fc" id="L814">			return id;</span>
		}

		/**
		 * @return the product status that was stored.
		 */
		public String getStatus() {
<span class="fc" id="L821">			return status;</span>
		}

		/**
		 * The productID is stored and can be found using getProductId().
		 */
		public void onBeginProduct(ProductId id, String status, URL trackerURL)
				throws Exception {
			// save the product id for later
<span class="fc" id="L830">			this.id = id;</span>
<span class="fc" id="L831">			this.status = status;</span>

			// acquire write lock for product
<span class="fc" id="L834">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L835">					+ &quot;] acquiring write lock for product id=&quot; + id.toString());</span>
<span class="fc" id="L836">			storageLocks.acquireWriteLock(id);</span>
			// keep track that we have write lock
<span class="fc" id="L838">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L839">					+ &quot;] acquired write lock for product id=&quot; + id.toString());</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">			if (hasProduct(id)) {</span>
<span class="fc" id="L841">				throw new ProductAlreadyInStorageException(&quot;[&quot; + getName()</span>
						+ &quot;] product already in storage&quot;);
			}

			// set the wrapped product output
<span class="fc" id="L846">			setProductOutput(getProductHandlerFormat(getProductFile(id)));</span>
			// call the directory product output onBeginProduct method to start
			// writing the product
<span class="fc" id="L849">			super.onBeginProduct(id, status, trackerURL);</span>
<span class="fc" id="L850">		}</span>

		public void onEndProduct(ProductId id) throws Exception {
			// call the directory product output onEndProduct method to finish
			// writing the product
<span class="fc" id="L855">			super.onEndProduct(id);</span>

			// DONT RELEASE THE LOCK HERE, this causes bigger problems on
			// hubs...

			// release the write lock
			// LOGGER.finest(&quot;Releasing write lock for product id=&quot; +
			// id.toString());
			// storageLocks.releaseWriteLock(id);
			// keep track that we no longer have write lock
			// this.haveWriteLock = false;
			// LOGGER.finest(&quot;Released write lock for product id=&quot; +
			// id.toString());
<span class="fc" id="L868">		}</span>
	}

	/**
	 * Called at client shutdown to free resources.
	 */
	public void shutdown() throws Exception {
		// Remove all our listeners. Doing this will also shut down the
		// ExecutorServices
<span class="fc" id="L877">		Iterator&lt;StorageListener&gt; listenerIter = listeners.keySet().iterator();</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">		while (listenerIter.hasNext()) {</span>
<span class="fc" id="L879">			removeStorageListener(listenerIter.next());</span>
			// Maybe we should call &quot;listener.shutdown()&quot; here as well?
		}

		// shutdown any legacy storages
<span class="fc" id="L884">		Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">		while (legacyIter.hasNext()) {</span>
<span class="nc" id="L886">			ProductStorage next = legacyIter.next();</span>
			try {
<span class="nc" id="L888">				next.shutdown();</span>
<span class="nc" id="L889">			} catch (Exception e) {</span>
<span class="nc" id="L890">				LOGGER.log(Level.FINE, &quot;[&quot; + getName()</span>
						+ &quot;] legacy storage shutdown exception &quot;, e);
<span class="nc" id="L892">			}</span>
<span class="nc" id="L893">		}</span>
<span class="fc" id="L894">	}</span>

	/**
	 * Called after client configuration to begin processing.
	 */
	public void startup() throws Exception {
		// startup any legacy storages
<span class="fc" id="L901">		Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">		while (legacyIter.hasNext()) {</span>
<span class="nc" id="L903">			ProductStorage next = legacyIter.next();</span>
			try {
<span class="nc" id="L905">				next.startup();</span>
<span class="nc" id="L906">			} catch (Exception e) {</span>
<span class="nc" id="L907">				LOGGER.log(Level.FINE, &quot;[&quot; + getName()</span>
						+ &quot;] legacy storage startup exception &quot;, e);
<span class="nc" id="L909">			}</span>
<span class="nc" id="L910">		}</span>
<span class="fc" id="L911">	}</span>

	/**
	 * @return the baseDirectory
	 */
	public File getBaseDirectory() {
<span class="fc" id="L917">		return baseDirectory;</span>
	}

	/**
	 * @param baseDirectory
	 *            the baseDirectory to set
	 */
	public void setBaseDirectory(File baseDirectory) {
<span class="nc" id="L925">		this.baseDirectory = baseDirectory;</span>
<span class="nc" id="L926">	}</span>

	/**
	 * @return the rejectInvalidSignatures
	 */
	public boolean isRejectInvalidSignatures() {
<span class="nc" id="L932">		return rejectInvalidSignatures;</span>
	}

	/**
	 * @param rejectInvalidSignatures
	 *            the rejectInvalidSignatures to set
	 */
	public void setRejectInvalidSignatures(boolean rejectInvalidSignatures) {
<span class="fc" id="L940">		this.rejectInvalidSignatures = rejectInvalidSignatures;</span>
<span class="fc" id="L941">	}</span>

	/**
	 * @return the testSignatures
	 */
	public boolean isTestSignatures() {
<span class="nc" id="L947">		return testSignatures;</span>
	}

	/**
	 * @param testSignatures
	 *            the testSignatures to set
	 */
	public void setTestSignatures(boolean testSignatures) {
<span class="fc" id="L955">		this.testSignatures = testSignatures;</span>
<span class="fc" id="L956">	}</span>

	/**
	 * @return the keychain
	 */
	public ProductKeyChain getKeychain() {
<span class="nc" id="L962">		return keychain;</span>
	}

	/**
	 * @param keychain
	 *            the keychain to set
	 */
	public void setKeychain(ProductKeyChain keychain) {
<span class="fc" id="L970">		this.keychain = keychain;</span>
<span class="fc" id="L971">	}</span>

	/**
	 * @return the legacyStorages.
	 */
	public List&lt;ProductStorage&gt; getLegacyStorages() {
<span class="fc" id="L977">		return legacyStorages;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>