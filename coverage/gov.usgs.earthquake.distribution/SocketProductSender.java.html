<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SocketProductSender.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.distribution</a> &gt; <span class="el_source">SocketProductSender.java</span></div><h1>SocketProductSender.java</h1><pre class="source lang-java linenums">/*
 * SocketProductSender
 */
package gov.usgs.earthquake.distribution;

import gov.usgs.earthquake.product.Product;
import gov.usgs.earthquake.product.io.BinaryIO;
import gov.usgs.earthquake.product.io.BinaryProductHandler;
import gov.usgs.earthquake.product.io.ObjectProductSource;
import gov.usgs.earthquake.product.io.XmlProductHandler;
import gov.usgs.earthquake.util.TimeoutOutputStream;
import gov.usgs.util.Config;
import gov.usgs.util.DefaultConfigurable;
import gov.usgs.util.StreamUtils;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.logging.Logger;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;

/**
 * Send Products to SocketProductReceivers.
 * 
 * The SocketProductSender implements the Configurable interface and uses the
 * following configuration parameters:
 * 
 * &lt;dl&gt;
 * &lt;dt&gt;host&lt;/dt&gt;
 * &lt;dd&gt;(Required) The IP address or hostname of a SocketProductReceiver.&lt;/dd&gt;
 * 
 * &lt;dt&gt;port&lt;/dt&gt;
 * &lt;dd&gt;(Optional, default=11235) The port on host of a SocketProductReceiver&lt;/dd&gt;
 * &lt;/dl&gt;
 * 
 * @author jmfee
 * 
 */
public class SocketProductSender extends DefaultConfigurable implements
		ProductSender {

	/** Logging object. */
<span class="fc" id="L53">	private static final Logger LOGGER = Logger</span>
<span class="fc" id="L54">			.getLogger(SocketProductSender.class.getName());</span>

	public static final String SENDER_HOST_PROPERTY = &quot;host&quot;;
	public static final String SENDER_PORT_PROPERTY = &quot;port&quot;;

	/** The default port number for SocketProductReceivers. */
	public static final String DEFAULT_SENDER_PORT = &quot;11235&quot;;

	public static final String CONNECT_TIMEOUT_PROPERTY = &quot;connectTimeout&quot;;
	public static final String DEFAULT_CONNECT_TIMEOUT = &quot;15000&quot;;

	public static final String READ_TIMEOUT_PROPERTY = &quot;readTimeout&quot;;
	public static final String DEFAULT_READ_TIMEOUT = &quot;15000&quot;;

	public static final String WRITE_TIMEOUT_PROPERTY = &quot;writeTimeout&quot;;
	public static final String DEFAULT_WRITE_TIMEOUT = &quot;-1&quot;;

	/** Property name to configure binary or xml format. */
	public static final String BINARY_FORMAT_PROPERTY = &quot;binaryFormat&quot;;
	/** Default value for whether to use binary format. */
	public static final String BINARY_FORMAT_DEFAULT = &quot;false&quot;;

	/** Property name to configure deflate compression. */
	public static final String ENABLE_DEFLATE_PROPERTY = &quot;enableDeflate&quot;;
	/** Default value for whether to use deflate compression. */
	public static final String ENABLE_DEFLATE_DEFAULT = &quot;true&quot;;

	public static final String DEFLATE_LEVEL_PROPERTY = &quot;deflateLevel&quot;;
	public static final String DEFLATE_LEVEL_DEFAULT = &quot;1&quot;;

	public static final String ENABLE_PDL_PROTOCOL_PROPERTY = &quot;enablePdlProtocol&quot;;
	public static final String DEFAULT_ENABLE_PDL_PROTOCOL = &quot;true&quot;;

<span class="fc" id="L87">	public static final byte[] PROTOCOL_HEADER = { 'P', 'D', 'L' };</span>
	public static final String PROTOCOL_VERSION_0_1 = &quot;v0.1&quot;;
	public static final String UNKNOWN_PRODUCT = &quot;Unknown product&quot;;
	public static final String ALREADY_HAVE_PRODUCT = &quot;Already have product&quot;;
	public static final String RECEIVE_ERROR = &quot;Error receiving product&quot;;

	/** Whether to store in binary format (true), or xml format (false). */
<span class="pc" id="L94">	private boolean binaryFormat = false;</span>

	/** Whether to deflate product sent over the wire. */
<span class="pc" id="L97">	private boolean enableDeflate = true;</span>

	/** Compression level when deflating products. */
<span class="pc" id="L100">	private int deflateLevel = 1;</span>

<span class="pc" id="L102">	private boolean enablePdlProtocol = true;</span>

	/** The remote hostname or ip address. */
<span class="pc" id="L105">	private String host = null;</span>
	/** The remote port. */
<span class="pc" id="L107">	private int port = -1; // -1 is invalid. This better be overridden.</span>
	/** How long to wait before connecting, in milliseconds. */
<span class="pc" id="L109">	private int connectTimeout = 15000;</span>
	/** How long to block while reading, before timing out. */
<span class="pc" id="L111">	private int readTimeout = 15000;</span>
	/** How long to block while writing, before timing out. */
<span class="pc" id="L113">	private int writeTimeout = -1;</span>

<span class="pc" id="L115">	private Socket socket = null;</span>

	/**
	 * Construct a new ProductSender.
	 * 
	 * @param host
	 * @param port
	 */
	public SocketProductSender(final String host, final int port) {
<span class="fc" id="L124">		this(host, port, Integer.parseInt(DEFAULT_CONNECT_TIMEOUT));</span>
<span class="fc" id="L125">	}</span>

	public SocketProductSender(final String host, final int port,
			final int connectTimeout) {
<span class="fc" id="L129">		this(host, port, connectTimeout,</span>
<span class="fc" id="L130">				Integer.parseInt(DEFAULT_READ_TIMEOUT), Integer</span>
<span class="fc" id="L131">						.parseInt(DEFAULT_WRITE_TIMEOUT));</span>
<span class="fc" id="L132">	}</span>

	public SocketProductSender(final String host, final int port,
			final int connectTimeout, final int readTimeout,
<span class="fc" id="L136">			final int writeTimeout) {</span>
<span class="fc" id="L137">		this.host = host;</span>
<span class="fc" id="L138">		this.port = port;</span>
<span class="fc" id="L139">		this.connectTimeout = connectTimeout;</span>
<span class="fc" id="L140">		this.readTimeout = readTimeout;</span>
<span class="fc" id="L141">		this.writeTimeout = writeTimeout;</span>
<span class="fc" id="L142">	}</span>

	/** Empty constructor for configurable interface. */
<span class="fc" id="L145">	public SocketProductSender() {</span>
<span class="fc" id="L146">	}</span>

	/**
	 * Construct a new ProductSender using a Config object.
	 * 
	 * @param config
	 * @throws Exception
	 */
<span class="nc" id="L154">	public SocketProductSender(Config config) throws Exception {</span>
<span class="nc" id="L155">		configure(config);</span>
<span class="nc" id="L156">	}</span>

	/**
	 * Implement the ProductSender interface.
	 * 
	 * Connects to host:port and sends a Deflaterped xml encoded Product. There
	 * is no direct response over the socket at this time.
	 * 
	 * Updates may be retrieved from a ProductTracker.
	 */
	public void sendProduct(Product product) throws Exception {
<span class="fc" id="L167">		BinaryIO io = new BinaryIO();</span>
<span class="fc" id="L168">		boolean sendProduct = true;</span>
<span class="fc" id="L169">		String status = null;</span>
<span class="fc" id="L170">		ObjectProductSource productSource = null;</span>
<span class="fc" id="L171">		InputStream in = null;</span>
<span class="fc" id="L172">		OutputStream out = null;</span>
		try {
<span class="fc" id="L174">			socket = new Socket();</span>
<span class="fc" id="L175">			socket.setSoTimeout(readTimeout);</span>
<span class="fc" id="L176">			socket.connect(new InetSocketAddress(host, port), connectTimeout);</span>
<span class="fc" id="L177">			LOGGER.info(&quot;[&quot; + getName() + &quot;] sending product to &quot;</span>
<span class="fc" id="L178">					+ socket.toString());</span>

<span class="fc" id="L180">			productSource = new ObjectProductSource(product);</span>

<span class="fc" id="L182">			in = new BufferedInputStream(socket.getInputStream());</span>
<span class="fc" id="L183">			out = new BufferedOutputStream(socket.getOutputStream());</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">			if (writeTimeout &gt; 0) {</span>
<span class="nc" id="L185">				out = new TimeoutOutputStream(out, writeTimeout);</span>
			}

<span class="pc bpc" id="L188" title="1 of 2 branches missed.">			if (enablePdlProtocol) {</span>
<span class="fc" id="L189">				LOGGER.fine(&quot;[&quot; + getName() + &quot;] using protocol version &quot;</span>
						+ PROTOCOL_VERSION_0_1);

				// flag to receiver for &quot;PDL&quot; protocol
<span class="fc" id="L193">				out.write(PROTOCOL_HEADER);</span>
<span class="fc" id="L194">				io.writeString(PROTOCOL_VERSION_0_1, out);</span>
<span class="fc" id="L195">				io.writeString(product.getId().toString(), out);</span>
<span class="fc" id="L196">				out.flush();</span>

<span class="fc" id="L198">				status = io.readString(in);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">				if (ALREADY_HAVE_PRODUCT.equals(status)) {</span>
<span class="fc" id="L200">					sendProduct = false;</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">				} else if (UNKNOWN_PRODUCT.equals(status)) {</span>
					// hub doesn't have this product, send
				} else {
					// unexpected reply, don't consider it success
<span class="nc" id="L205">					throw new Exception(&quot;Unexpected hub reply '&quot; + status + &quot;'&quot;);</span>
				}
			} else {
<span class="nc" id="L208">				LOGGER.fine(&quot;[&quot; + getName() + &quot;] not using PDL protocol&quot;);</span>
			}

<span class="fc bfc" id="L211" title="All 2 branches covered.">			if (sendProduct) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">				if (enableDeflate) {</span>
<span class="fc" id="L213">					out = new DeflaterOutputStream(out, new Deflater(</span>
							deflateLevel));
				}

				// make sure product handler doesn't close stream before done
<span class="fc" id="L218">				OutputStream productOut = new StreamUtils.UnclosableOutputStream(</span>
						out);
<span class="fc bfc" id="L220" title="All 2 branches covered.">				if (binaryFormat) {</span>
<span class="fc" id="L221">					productSource</span>
<span class="fc" id="L222">							.streamTo(new BinaryProductHandler(productOut));</span>
				} else {
<span class="fc" id="L224">					productSource.streamTo(new XmlProductHandler(productOut));</span>
				}

				// deflate requires &quot;finish&quot;
<span class="fc bfc" id="L228" title="All 2 branches covered.">				if (enableDeflate) {</span>
<span class="fc" id="L229">					((DeflaterOutputStream) out).finish();</span>
				}

				// flush buffered output stream to socket
<span class="fc" id="L233">				out.flush();</span>
				// mark end of stream for server (for xml parser)
<span class="fc" id="L235">				socket.shutdownOutput();</span>

				// finished sending, now get status from server
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">				if (enablePdlProtocol) {</span>
					// the new way
<span class="fc" id="L240">					status = io.readString(in);</span>
				} else {
					// the old way
<span class="nc" id="L243">					status = new BufferedReader(new InputStreamReader(</span>
<span class="nc" id="L244">							socket.getInputStream())).readLine();</span>
				}
			}

<span class="fc" id="L248">			LOGGER.info(&quot;[&quot; + getName() + &quot;] send complete &quot;</span>
<span class="fc" id="L249">					+ socket.toString() + &quot; response=\&quot;&quot; + status + &quot;\&quot;&quot;);</span>
<span class="nc" id="L250">		} catch (SocketTimeoutException ste) {</span>
<span class="nc" id="L251">			throw new Exception(&quot;Error sending to &quot; + host</span>
					+ &quot;, connect or read timeout&quot;, ste);
<span class="nc" id="L253">		} catch (UnknownHostException uhe) {</span>
<span class="nc" id="L254">			throw new Exception(&quot;Unknown host &quot; + host</span>
					+ &quot;, check that DNS is properly configured&quot;, uhe);
<span class="nc" id="L256">		} catch (SocketException se) {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			if (!enablePdlProtocol) {</span>
				// check the old way
				try {
					// possible that hub already has product
<span class="nc" id="L261">					status = new BufferedReader(new InputStreamReader(</span>
<span class="nc" id="L262">							socket.getInputStream())).readLine();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">					if (status.equals(&quot;Product already received&quot;)) {</span>
						// hub already has product
<span class="nc" id="L265">						LOGGER.info(&quot;[&quot; + getName()</span>
								+ &quot;] hub already has product&quot;);
<span class="nc" id="L267">						return;</span>
					}
<span class="nc" id="L269">				} catch (Exception e) {</span>
					// ignore, already have an exception
<span class="nc" id="L271">					e.printStackTrace();</span>
<span class="nc" id="L272">				}</span>
			}
<span class="nc" id="L274">			throw new Exception(&quot;Error sending to &quot; + host</span>
					+ &quot;, possible write timeout&quot;, se);
<span class="nc" id="L276">		} catch (Exception e) {</span>
<span class="nc" id="L277">			throw new Exception(&quot;[&quot; + getName() + &quot;] error sending to &quot; + host,</span>
					e);
		} finally {
			try {
<span class="fc" id="L281">				out.close();</span>
<span class="nc" id="L282">			} catch (Exception ignore) {</span>
<span class="fc" id="L283">			}</span>
<span class="fc" id="L284">			socket.close();</span>
<span class="fc" id="L285">			socket = null;</span>
		}

<span class="pc bpc" id="L288" title="2 of 4 branches missed.">		if (status != null &amp;&amp; status.startsWith(&quot;Error&quot;)) {</span>
<span class="nc" id="L289">			throw new Exception(&quot;[&quot; + getName() + &quot;] error sending to &quot; + host</span>
					+ &quot;, message=&quot; + status);
		}
<span class="fc" id="L292">	}</span>

	/**
	 * Reads the host and port from config.
	 * 
	 * @param config
	 *            a Config object with host and port properties.
	 */
	public void configure(Config config) throws Exception {
<span class="nc" id="L301">		host = config.getProperty(SENDER_HOST_PROPERTY);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">		if (host == null) {</span>
<span class="nc" id="L303">			throw new ConfigurationException(&quot;[&quot; + getName()</span>
					+ &quot;] 'host' is a required configuration property&quot;);
		}
<span class="nc" id="L306">		LOGGER.config(&quot;[&quot; + getName() + &quot;] host is '&quot; + host + &quot;'&quot;);</span>

<span class="nc" id="L308">		port = Integer.parseInt(config.getProperty(SENDER_PORT_PROPERTY,</span>
<span class="nc" id="L309">				DEFAULT_SENDER_PORT).trim());</span>
<span class="nc" id="L310">		LOGGER.config(&quot;[&quot; + getName() + &quot;] port is '&quot; + port + &quot;'&quot;);</span>

<span class="nc" id="L312">		connectTimeout = Integer.parseInt(config.getProperty(</span>
				CONNECT_TIMEOUT_PROPERTY, DEFAULT_CONNECT_TIMEOUT));
<span class="nc" id="L314">		LOGGER.config(&quot;[&quot; + getName() + &quot;] connectTimeout is '&quot;</span>
				+ connectTimeout + &quot;'&quot;);

<span class="nc" id="L317">		readTimeout = Integer.parseInt(config.getProperty(</span>
				READ_TIMEOUT_PROPERTY, DEFAULT_READ_TIMEOUT));
<span class="nc" id="L319">		LOGGER.config(&quot;[&quot; + getName() + &quot;] readTimeout is '&quot; + readTimeout</span>
				+ &quot;'&quot;);

<span class="nc" id="L322">		writeTimeout = Integer.parseInt(config.getProperty(</span>
				WRITE_TIMEOUT_PROPERTY, DEFAULT_WRITE_TIMEOUT));
<span class="nc" id="L324">		LOGGER.config(&quot;[&quot; + getName() + &quot;] writeTimeout is '&quot; + writeTimeout</span>
				+ &quot;'&quot;);

<span class="nc" id="L327">		binaryFormat = Boolean.valueOf(config.getProperty(</span>
				BINARY_FORMAT_PROPERTY, BINARY_FORMAT_DEFAULT));
<span class="nc" id="L329">		LOGGER.config(&quot;[&quot; + getName() + &quot;] using &quot;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">				+ (binaryFormat ? &quot;binary&quot; : &quot;xml&quot;) + &quot; format&quot;);</span>

<span class="nc" id="L332">		enableDeflate = Boolean.valueOf(config.getProperty(</span>
				ENABLE_DEFLATE_PROPERTY, ENABLE_DEFLATE_DEFAULT));
<span class="nc" id="L334">		LOGGER.config(&quot;[&quot; + getName() + &quot;] enableDeflate is &quot; + enableDeflate);</span>

<span class="nc" id="L336">		deflateLevel = Integer.valueOf(config.getProperty(</span>
				DEFLATE_LEVEL_PROPERTY, DEFLATE_LEVEL_DEFAULT));
<span class="nc" id="L338">		LOGGER.config(&quot;[&quot; + getName() + &quot;] deflateLevel is &quot; + deflateLevel);</span>

<span class="nc" id="L340">		enablePdlProtocol = Boolean.valueOf(config.getProperty(</span>
				ENABLE_PDL_PROTOCOL_PROPERTY, DEFAULT_ENABLE_PDL_PROTOCOL));
<span class="nc" id="L342">		LOGGER.config(&quot;[&quot; + getName() + &quot;] enablePdlProtocol is &quot;</span>
				+ enablePdlProtocol);
<span class="nc" id="L344">	}</span>

	/**
	 * Makes sure the socket is closed.
	 */
	public void shutdown() throws Exception {
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">		if (socket != null) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">			if (!socket.isOutputShutdown()) {</span>
				try {
<span class="nc" id="L353">					socket.getOutputStream().flush();</span>
<span class="nc" id="L354">					socket.getOutputStream().close();</span>
<span class="nc" id="L355">				} catch (IOException iox) { /* Ignore */</span>
<span class="nc" id="L356">				}</span>
			}
<span class="nc bnc" id="L358" title="All 2 branches missed.">			if (!socket.isClosed()) {</span>
				try {
<span class="nc" id="L360">					socket.close();</span>
<span class="nc" id="L361">				} catch (IOException iox) { /* Ignore */</span>
<span class="nc" id="L362">				}</span>
			}
		}
<span class="fc" id="L365">	}</span>

	/**
	 * Does nothing, a socket is opened each time a product is sent.
	 */
	public void startup() throws Exception {
		// Nothing to do for startup...
<span class="fc" id="L372">	}</span>

	/**
	 * @return the binaryFormat
	 */
	public boolean isBinaryFormat() {
<span class="nc" id="L378">		return binaryFormat;</span>
	}

	/**
	 * @param binaryFormat
	 *            the binaryFormat to set
	 */
	public void setBinaryFormat(boolean binaryFormat) {
<span class="fc" id="L386">		this.binaryFormat = binaryFormat;</span>
<span class="fc" id="L387">	}</span>

	/**
	 * @return the enableDeflate
	 */
	public boolean isEnableDeflate() {
<span class="nc" id="L393">		return enableDeflate;</span>
	}

	/**
	 * @param enableDeflate
	 *            the enableDeflate to set
	 */
	public void setEnableDeflate(boolean enableDeflate) {
<span class="fc" id="L401">		this.enableDeflate = enableDeflate;</span>
<span class="fc" id="L402">	}</span>

	/**
	 * @return the deflateLevel
	 */
	public int getDeflateLevel() {
<span class="nc" id="L408">		return deflateLevel;</span>
	}

	/**
	 * @param deflateLevel
	 *            the deflateLevel to set
	 */
	public void setDeflateLevel(int deflateLevel) {
<span class="nc" id="L416">		this.deflateLevel = deflateLevel;</span>
<span class="nc" id="L417">	}</span>

	/**
	 * @return the enablePdlProtocol
	 */
	public boolean isEnablePdlProtocol() {
<span class="nc" id="L423">		return enablePdlProtocol;</span>
	}

	/**
	 * @param enablePdlProtocol
	 *            the enablePdlProtocol to set
	 */
	public void setEnablePdlProtocol(boolean enablePdlProtocol) {
<span class="nc" id="L431">		this.enablePdlProtocol = enablePdlProtocol;</span>
<span class="nc" id="L432">	}</span>

	/**
	 * @return the connectTimeout
	 */
	public int getConnectTimeout() {
<span class="nc" id="L438">		return connectTimeout;</span>
	}

	/**
	 * @param connectTimeout
	 *            the connectTimeout to set
	 */
	public void setConnectTimeout(int connectTimeout) {
<span class="nc" id="L446">		this.connectTimeout = connectTimeout;</span>
<span class="nc" id="L447">	}</span>

	/**
	 * @return the readTimeout
	 */
	public int getReadTimeout() {
<span class="nc" id="L453">		return readTimeout;</span>
	}

	/**
	 * @param readTimeout
	 *            the readTimeout to set
	 */
	public void setReadTimeout(int readTimeout) {
<span class="nc" id="L461">		this.readTimeout = readTimeout;</span>
<span class="nc" id="L462">	}</span>

	/**
	 * @return the writeTimeout
	 */
	public int getWriteTimeout() {
<span class="nc" id="L468">		return writeTimeout;</span>
	}

	/**
	 * @param writeTimeout
	 *            the writeTimeout to set
	 */
	public void setWriteTimeout(int writeTimeout) {
<span class="nc" id="L476">		this.writeTimeout = writeTimeout;</span>
<span class="nc" id="L477">	}</span>

	/**
	 * @return the host
	 */
	public String getHost() {
<span class="nc" id="L483">		return host;</span>
	}

	/**
	 * @param host
	 *            the host to set
	 */
	public void setHost(String host) {
<span class="fc" id="L491">		this.host = host;</span>
<span class="fc" id="L492">	}</span>

	/**
	 * @return the port
	 */
	public int getPort() {
<span class="nc" id="L498">		return port;</span>
	}

	/**
	 * @param port
	 *            the port to set
	 */
	public void setPort(int port) {
<span class="fc" id="L506">		this.port = port;</span>
<span class="fc" id="L507">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>